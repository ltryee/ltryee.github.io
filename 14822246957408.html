
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  iOS 控件设置圆角（下） - ltryee's blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="ltryee's blog">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ltryee's blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ltryee's blog</a></h1>
  
    <h2>ltryee's blog</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:ltryee.gitee.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div>
	<article class="hentry" role="article">
	<header>
			  	<h1 class="entry-title">iOS 控件设置圆角（下）</h1>
				<p class="meta"><time datetime="2016-12-20T17:04:55+08:00" pubdate data-updated="true">2016/12/20</time></p>
			 </header>
		  	<div class="entry-content">
			  	<div class="mweb_toc"><ul>
<li><a href="#%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95">提升性能的几种方法</a>
<ul>
<li><a href="#%E5%85%89%E6%A0%85%E5%8C%96">光栅化</a></li>
<li><a href="#%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87">裁剪图片</a></li>
<li><a href="#%E5%9C%86%E8%A7%92%E9%81%AE%E7%BD%A9">圆角遮罩</a></li>
<li><a href="#%E5%9C%86%E8%A7%92%E8%83%8C%E6%99%AF%E5%9B%BE">圆角背景图</a></li>
<li><a href="#%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E7%B1%BB%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%9C%86%E8%A7%92">文本视图类上实现圆角</a></li>
</ul>
</li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</div>
<p>圆角是iOS系统中常见的视觉样式，从系统图标到导航栏按钮，圆角无处不在。因为圆角是符合人类视觉安全体验的，圆角让人觉得舒适，而尖角在潜意识层次是具有伤害体验的，因为尖尖的东西总是有可能对人造成伤害的，所以我们更喜欢圆角。在iOS开发过程中，苹果提供了一种添加圆角的方法，简单暴力有效，但并不是所有的开发者都清楚原理，因此设置圆角有时会带来一定的性能损耗。</p>
<p>上一篇文章从理论上介绍设置圆角方法，性能损耗的原因这两方面展开讨论。本文将从具体项目的实践中介绍如何避免性能损耗。</p>
<h2><a id="%E6%8F%90%E5%8D%87%E6%80%A7%E8%83%BD%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>提升性能的几种方法</h2>
<p>前文已经提到，圆角设置不当会导致系统进行离屏渲染，进而造成卡顿和跳帧。具体到项目实践中，解决问题的途径有两种：一是尽量减小离屏渲染造成的CPU/GPU资源消耗，达到减缓卡顿的程度，下面将要介绍的光栅化(Rasterization)就是遵循这个思路的解决途径；二是通过其他方法实现『圆形的角』效果，尽量避免离屏渲染。具体方法包括裁剪图片，圆角遮罩等。</p>
<h3><a id="%E5%85%89%E6%A0%85%E5%8C%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>光栅化</h3>
<p>光栅化(Rasterization)，将layer渲染为bitmap存储于帧缓冲区中(一种特殊的离屏渲染)，每个像素对应帧缓冲区中的一像素。开启光栅化只需下面两行代码：</p>
<pre class="line-numbers"><code class="language-plain_text">view.layer.shouldRasterize = YES;
view.layer.rasterizationScale = cell.layer.contentsScale;
</code></pre>
<p>以下是<a href="http://liutianyangdeiMac.local:51239/Dash/oqpyzwaw/developer.apple.com/reference/quartzcore/calayer/1410905-shouldrasterize1742.html">官方文档</a>对<code>shouldRasterize</code>属性的解释：</p>
<blockquote>
<p>When the value of this property is YES, the layer is rendered as a bitmap in its local coordinate space and then composited to the destination with any other content. Shadow effects and any filters in the filters property are rasterized and included in the bitmap. However, the current opacity of the layer is not rasterized.</p>
</blockquote>
<p><code>shouldRasterize = YES</code>在其他属性触发离屏渲染的同时，会将光栅化后的内容缓存起来，如果对应的layer及其sublayers没有发生改变，在下一帧的时候可以直接复用。<code>shouldRasterize = YES</code>，这将隐式的创建一个位图，各种阴影遮罩等效果也会保存到位图中并缓存起来，从而减少渲染的频度（不是矢量图）。(<a href="http://www.jianshu.com/p/6d24a4c29e18">来源</a>)</p>
<p>开启光栅化后，GPU 只合成一次内容，然后复用合成的结果；合成的内容超过 100ms 没有使用会从缓存里移除，在更新内容时还会产生<strong>更多的</strong>离屏渲染。对于内容不发生变化的视图，原本拖后腿的离屏渲染就成为了助力；如果视图内容是动态变化的，使用这个方案有可能让性能变得更糟。</p>
<h3><a id="%E8%A3%81%E5%89%AA%E5%9B%BE%E7%89%87" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>裁剪图片</h3>
<p>我们得到一张图片之后，对图片本身进行裁剪，把图片的直角裁剪为圆角。以后每次使用此图片时，都是一张带圆角的图片，这就从源头控制了后续获取圆角的各种操作，非常适用于频繁动态更新的场景。</p>
<pre class="line-numbers"><code class="language-objc">- (UIImage *)roundedCornerImageWithCornerRadius:(CGFloat)cornerRadius
{
    CGFloat w = self.size.width;
    CGFloat h = self.size.height;
    CGFloat scale = [UIScreen mainScreen].scale;
    
    // 防止圆角半径小于0，或者大于宽/高中较小值的一半。
    if (cornerRadius &lt; 0) {
        cornerRadius = 0;
    }
    else if (cornerRadius &gt; MIN(w, h)) {
        cornerRadius = MIN(w, h) / 2.;
    }
    
    UIImage *image = nil;
    CGRect imageFrame = CGRectMake(0., 0., w, h);
    UIGraphicsBeginImageContextWithOptions(self.size, NO, scale);
    [[UIBezierPath bezierPathWithRoundedRect:imageFrame cornerRadius:cornerRadius] addClip];
    [self drawInRect:imageFrame];
    image = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    
    return image;
}
</code></pre>
<h3><a id="%E5%9C%86%E8%A7%92%E9%81%AE%E7%BD%A9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>圆角遮罩</h3>
<p>在要添加圆角的视图上再叠加一个部分透明的视图，只对圆角部分进行遮挡。遮挡的部分背景最好与周围背景相同。多一个图层会增加合成的工作量，但这点工作量与离屏渲染相比微不足道，性能上无论各方面都和无效果持平。如果叠加的视图都一样，可以只加载一次遮罩图片以减少内存占用。</p>
<p>除了用软件画出来保存在项目里，直接用代码画出来也是很简单的。在一个设置<code>opaque = NO</code>的 CGContext 里，设定填充颜色然后用两条曲线围成一个封闭区域，最后从这个绘制环境导出图像即可。</p>
<pre class="line-numbers"><code class="language-objc">/**
 *  生成一张图片，用于遮盖UIView的四角，使UIView呈现圆角效果
 *
 *  @param color  遮罩颜色
 *  @param radius 圆角半径
 *
 *  @return 一张resizable图片，图片尺寸(2 * radius + 1) * (2 * radius + 1)，中心的1px为透明色，用于拉伸
 */
 + (UIImage *)roundedCornerMaskImageWithColor:(UIColor *)color radius:(CGFloat)radius
{
    if (radius &lt;= 0) {
        return nil;
    }
    
    CGRect rect = CGRectMake(0, 0, radius * 2 + 1, radius * 2 + 1);
    
    UIGraphicsBeginImageContextWithOptions(rect.size, NO, 0.0);
    CGContextRef context = UIGraphicsGetCurrentContext();
    
    [color set];
    
    CGPathRef rectPath = CGPathCreateWithRect(rect, NULL);
    CGContextAddPath(context, rectPath);
    CGPathRef roundedCornerPath = CGPathCreateWithRoundedRect(rect, radius, radius, NULL);
    CGContextAddPath(context, roundedCornerPath);
    CGContextEOFillPath(context);
    
    UIImage *maskImage = UIGraphicsGetImageFromCurrentImageContext();
    
    UIGraphicsEndImageContext();
    CGPathRelease(rectPath);
    CGPathRelease(roundedCornerPath);
    
    return [maskImage resizableImageWithCapInsets:UIEdgeInsetsMake(radius, radius, radius, radius)];
}
</code></pre>
<h3><a id="%E5%9C%86%E8%A7%92%E8%83%8C%E6%99%AF%E5%9B%BE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>圆角背景图</h3>
<p>生成一张圆角图片，叠加在目标视图的最底部。效率和圆角遮罩一样。这种方法特别适用于<code>UIButton</code>，调用<code>UIButton</code>的<code>setBackgroundImage:forState:</code>方法，将生成的图片设置为背景图即可。</p>
<pre class="line-numbers"><code class="language-objc">- (UIImage *)roundedCorner:(CGFloat)cornerRadius tintedGradientColor:(UIColor *)tintColor
{
    CGFloat w = self.size.width;
    CGFloat h = self.size.height;
    CGFloat scale = [UIScreen mainScreen].scale;
    // 防止圆角半径小于0，或者大于宽/高中较小值的一半。
    if (cornerRadius &lt; 0)
        cornerRadius = 0;
    else if (cornerRadius &gt; MIN(w, h))
        cornerRadius = MIN(w, h) / 2.;
    
    CGRect imageFrame = CGRectMake(0., 0., w, h);
    UIGraphicsBeginImageContextWithOptions(self.size, NO, scale);
    [[UIBezierPath bezierPathWithRoundedRect:imageFrame cornerRadius:cornerRadius] addClip];
    [self drawInRect:imageFrame];
    
    [tintColor setFill];
    UIRectFill(imageFrame);
    [self drawInRect:imageFrame blendMode:kCGBlendModeOverlay alpha:1.0f];
    
    UIImage *tintedImage = UIGraphicsGetImageFromCurrentImageContext();
    UIGraphicsEndImageContext();
    
    return tintedImage;
}
</code></pre>
<h3><a id="%E6%96%87%E6%9C%AC%E8%A7%86%E5%9B%BE%E7%B1%BB%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%9C%86%E8%A7%92" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>文本视图类上实现圆角</h3>
<p>文本视图主要是这三类：<code>UILabel</code>, <code>UITextField</code>, <code>UITextView</code>。其中 <code>UITextField</code> 类自带圆角风格的外型，<code>UILabel</code> 和 <code>UITextView</code> 要想显示圆角需要表现出与周围不同的背景色才行。想要在 <code>UILabel</code> 和 <code>UITextView</code> 上实现低成本的圆角(不触发离屏渲染)，需要保证 <code>layer</code> 的<code>contents</code>呈现透明的背景色，文本视图类的 <code>layer</code> 的<code>contents</code>默认是透明的(字符就在这个透明的环境里绘制、显示)，此时只需要设置 <code>layer</code> 的<code>backgroundColor</code>，再加上<code>cornerRadius</code>就可以搞定了。不过 <code>UILabel</code> 上设置<code>backgroundColor</code>的行为被更改了，不再是设定 <code>layer</code> 的背景色而是为<code>contents</code>设置背景色，<code>UITextView</code> 则没有改变这一点，所以在 UILabel 上实现圆角要这么做：</p>
<pre class="line-numbers"><code class="language-objc">//不要这么做：label.backgroundColor = aColor 以及不要在 IB 里为 label 设置背景色
label.layer.backgroundColor = aColor;
label.layer.cornerRadius = 5;
</code></pre>
<h2><a id="%E6%80%BB%E7%BB%93" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>总结</h2>
<ol>
<li>光栅化(Rasterization)可以有效提高帧率，前提是layer的contents<strong>不</strong>频繁更新。</li>
<li>裁剪图片可以一劳永逸地解决生成图片圆角的问题，但仅限于图片，不能有多个视图叠加在图片之上。同时一旦裁剪完成，圆角大小就不可更改，适用范围很窄。</li>
<li>圆角遮罩方法在目标视图上再添加一层视图，可以盖住底层所有的视图，可扩展性强，但要求父视图是<strong>纯色背景</strong>。</li>
<li>没有哪种方法可以cover所有的情况，总有一种情况没有办法做任何优化，听天由命吧……</li>
</ol>

			</div>

		
	  
		<footer>
		 <p class="meta">

			
			<span class="categories">
			 
			</span>
		    </p>
		    <p class="meta">
		      
		 </p>
	    
		<div class="sharing">
		  
          

          

		</div>

	    <p class="meta">
	    
	        <a class="basic-alignment left" href="14822246957173.html" 
	        title="Previous Post: iOS 控件设置圆角（上）">&laquo; iOS 控件设置圆角（上）</a>
	    
	    
	    </p>
	  </footer>
	</article>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E3%80%8AiOS%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><strong>《iOS面试之道》读书笔记&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="16566860725573.html">使用 framework 转换 XCFramework</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="16558196375003.html">记一次私有 pod 发布报错</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="wan-zhuan-cocoapods-xu-yao-le.html">玩转 CocoaPods 需要了解的 Ruby 基础知识</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="16553980014674.html">使用 LLDB Python API 自动存储后台请求数据用于单元测试</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15372506301626.html">JavaScript for Automation(JXA) 入门</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>



  













<script src="asset/prism.js"></script>


<style type="text/css">
  
/* PrismJS 1.14.0
https://prismjs.com/download.html#themes=prism-solarizedlight&languages=markup+css+clike+javascript */
/*
 Solarized Color Schemes originally by Ethan Schoonover
 http://ethanschoonover.com/solarized

 Ported for PrismJS by Hector Matos
 Website: https://krakendev.io
 Twitter Handle: https://twitter.com/allonsykraken)
*/

/*
SOLARIZED HEX
--------- -------
base03    #002b36
base02    #073642
base01    #586e75
base00    #657b83
base0     #839496
base1     #93a1a1
base2     #eee8d5
base3     #fdf6e3
yellow    #b58900
orange    #cb4b16
red       #dc322f
magenta   #d33682
violet    #6c71c4
blue      #268bd2
cyan      #2aa198
green     #859900
*/

code[class*="language-"],
pre[class*="language-"] {
  color: #657b83; /* base00 */
  font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;

  line-height: 1.5;

  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
  background: #073642; /* base02 */
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
  background: #073642; /* base02 */
}

/* Code blocks */
pre[class*="language-"] {
  padding: 1em;
  margin: .5em 0;
  overflow: auto;
  border-radius: 0.3em;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
  background-color: #fdf6e3; /* base3 */
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: #93a1a1; /* base1 */
}

.token.punctuation {
  color: #586e75; /* base01 */
}

.namespace {
  opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
  color: #268bd2; /* blue */
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.url,
.token.inserted {
  color: #2aa198; /* cyan */
}

.token.entity {
  color: #657b83; /* base00 */
  background: #eee8d5; /* base2 */
}

.token.atrule,
.token.attr-value,
.token.keyword {
  color: #859900; /* green */
}

.token.function,
.token.class-name {
  color: #b58900; /* yellow */
}

.token.regex,
.token.important,
.token.variable {
  color: #cb4b16; /* orange */
}

.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}

.token.entity {
  cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>
  
    


</body>
</html>