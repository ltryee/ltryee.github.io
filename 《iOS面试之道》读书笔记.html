
<!DOCTYPE html>
<!--[if IEMobile 7 ]><html class="no-js iem7"><![endif]-->
<!--[if lt IE 9]><html class="no-js lte-ie8"><![endif]-->
<!--[if (gt IE 8)|(gt IEMobile 7)|!(IEMobile)|!(IE)]><!--><html class="no-js"><!--<![endif]-->
<head>
  <meta charset="utf-8">
  <title>
    
  《iOS面试之道》读书笔记 - ltryee's blog
  

  </title>
  <meta name="author" content="">
  <meta name="description" content="ltryee's blog">

  <meta name="HandheldFriendly" content="True">
  <meta name="MobileOptimized" content="320">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  
  <link href="asset/css/screen.css" media="screen, projection" rel="stylesheet" type="text/css">
  <link href="atom.xml" rel="alternate" title="ltryee's blog" type="application/atom+xml">
  <script src="asset/js/modernizr-2.0.js"></script>
  <script src="asset/js/jquery.min.js"></script>
  <style type="text/css">
  .cat-children-p{ padding: 6px 0px;}
  .hljs{background: none;}
  </style>
  <script type="text/javascript">
  var isAddSildbar = true;
  </script>
  <script src="asset/js/octopress.js" type="text/javascript"></script>
</head>
<script type="text/javascript">
//链接新开窗口
function addBlankTargetForLinks () {
  $('a[href^="http"]').each(function(){
      $(this).attr('target', '_blank');
  });
}
$(document).ready(function(event) {
  addBlankTargetForLinks();
});
</script>
<body   >
  <header role="banner"><hgroup>
  <h1><a href="index.html">ltryee's blog</a></h1>
  
    <h2>ltryee's blog</h2>
  
</hgroup>

</header>
  <nav role="navigation"><ul class="subscription" data-subscription="rss">
  <li><a href="atom.xml" rel="subscribe-rss" title="subscribe via RSS">RSS</a></li>
  
</ul>
  
<form action="http://google.com/search" method="get">
  <fieldset role="search">
    <input type="hidden" name="q" value="site:ltryee.gitee.io" />
    <input class="search" type="text" name="q" results="0" placeholder="Search"/>
  </fieldset>
</form>
  
<ul class="main-navigation">

  <li id=""><a target="_self" href="index.html">Home</a></li>

  <li id=""><a target="_self" href="archives.html">Archives</a></li>

</ul>

</nav>
  <div id="main">
    <div id="content"> 
<div class="blog-index">

	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15366534889994.html">《iOS面试之道》读书笔记 - 网络请求相关</a></h1>
			<p class="meta"><time datetime="2018-09-11T16:11:28+08:00" 
			pubdate data-updated="true">2018/09/11</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#url-loading-system">URL Loading System</a>
<ul>
<li><a href="#nsurlsession">NSURLSession</a>
<ul>
<li><a href="#session%E7%B1%BB%E5%9E%8B">Session类型</a></li>
<li><a href="#task%E7%B1%BB%E5%9E%8B">Task类型</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8delegate">使用delegate</a></li>
<li><a href="#%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7">线程安全性</a></li>
</ul>
</li>
<li><a href="#nsurlsessiontask">NSURLSessionTask</a></li>
<li><a href="#nsurlsessionconfiguration">NSURLSessionConfiguration</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA">创建</a></li>
<li><a href="#%E5%8F%AF%E9%85%8D%E7%BD%AE%E9%A1%B9">可配置项</a></li>
</ul>
</li>
<li><a href="#%E5%A4%84%E7%90%86%E9%89%B4%E6%9D%83%E6%9F%A5%E8%AF%A2authentication-challenge">处理鉴权查询(Authentication Challenge)</a></li>
</ul>
</li>
<li><a href="#nsurlconnection-vs-nsurlsession">NSURLConnection vs. NSURLSession</a></li>
<li><a href="#ats">ATS</a>
<ul>
<li><a href="#ats%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE">ATS 基本配置</a></li>
<li><a href="#%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE">自定义配置</a>
<ul>
<li><a href="#%E5%85%A8%E9%83%A8%E5%90%AF%E7%94%A8ats">全部启用 ATS</a></li>
<li><a href="#%E5%85%A8%E9%83%A8%E5%90%AF%E7%94%A8ats%EF%BC%8C%E4%BD%86%E6%9C%89%E4%B8%80%E4%BA%9B%E4%BE%8B%E5%A4%96">全部启用 ATS，但有一些例外</a></li>
<li><a href="#%E5%85%A8%E9%83%A8%E7%A6%81%E7%94%A8ats%EF%BC%8C%E4%BD%86%E6%9C%89%E4%B8%80%E4%BA%9B%E4%BE%8B%E5%A4%96">全部禁用 ATS，但有一些例外</a></li>
<li><a href="#%E9%99%8D%E7%BA%A7%E7%9A%84ats">降级的 ATS</a></li>
<li><a href="#%E5%85%A8%E9%83%A8%E7%A6%81%E7%94%A8ats">全部禁用 ATS</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<h2><a id="url-loading-system" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>URL Loading System</h2>
<p>URL加载系统使用诸如标准的<em>https</em>或自定义协议，提供访问基于URL标识的资源的能力。加载是异步执行的，因此您的应用程序可以响应其他事件并在加载数据或错误到达时转回处理。<br />
您可以使用<a href="https://developer.apple.com/documentation/foundation/nsurlsession?language=objc"><code>NSURLSession</code></a>实例创建一个或多个<a href="https://developer.apple.com/documentation/foundation/nsurlsessiontask?language=objc"><code>NSURLSessionTask</code></a>实例，这些实例可以获取数据并将数据返回到应用程序，下载文件或将数据和文件上载到远程位置。要配置会话，请使用一个<a href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration?language=objc"><code>NSURLSessionConfiguration</code></a>对象，该对象控制如何使用cache和cookie，或者是否允许在蜂窝网络上进行连接。<br />
您可以重复使用一个会话(session)来创建任务(task)。例如，Web浏览器可能使用多个会话，分别负责常规和隐私浏览，其中私有会话不提供缓存数据的能力。下图显示了具有这些配置的两个会话如何创建多个任务。</p>
<p><img src="https://docs-assets.developer.apple.com/published/4bf9c6d271/6789dd96-afdc-4c18-b8eb-01f9012dc04d.png" alt="Creating tasks from URL sessions" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;" /></p>
<p>每个会话都与一个*委托(delegate)*相关联，以接收定期更新（或error）。默认委托调用您提供的completion handler block; 如果您选择提供自己的自定义delegate，则不会调用此block。<br />
您可以将会话配置为在后台运行，以便在应用程序暂停时，系统可以代为下载数据并唤醒app以提供结果<sup class="footnote-ref"><a href="#fn-1" id="fnref-1_ref" data-footnote-ref>1</a></sup>。</p>
<h3><a id="nsurlsession" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NSURLSession</h3>
<blockquote>
<p><code>NSURLSession</code>: 协调一组相关网络数据传输任务的对象。</p>
</blockquote>
<p>NSURLSession类和相关类提供下载内容的API。你可以使用NSURLSession API创建一个或多个会话，每个会话都会协调一组相关的数据传输任务<sup class="footnote-ref"><a href="#fn-2" id="fnref-2_ref" data-footnote-ref>2</a></sup>。</p>
<h4><a id="session%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Session类型</h4>
<p>NSURLSession拥有一个没有配置对象的单例<a href="https://developer.apple.com/documentation/foundation/nsurlsession/1409000-sharedsession?language=objc"><code>sharedSession</code></a>，可用于处理基本请求。对于其他类型的session，你可以使用以下配置：</p>
<ul>
<li>*默认会话(Default session)*类似共享session，允许更多的配置，并允许使用delegate获取增量数据。</li>
<li>*临时会话(Ephemeral session)*类似共享session，但不缓存cache，cookie或凭据到磁盘。</li>
<li>*后台会话(Background session)*可以在app未运行时在后台执行上传或下载内容的操作。</li>
</ul>
<h4><a id="task%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Task类型</h4>
<p>在使用session的过程中，你可以通过创建task的方式完成上传、下载数据等操作。NSURLSession API提供了三种类型的任务：</p>
<ul>
<li>*数据任务(Data task)*用于发送和接收<code>NSData</code>。</li>
<li>*上传任务(Upload task)*类似于数据任务，但也能用于发送文件数据，并支持在app未运行时后台上传。</li>
<li>*下载任务(Download task)*以文件的形式获取数据，同时支持后台下载。</li>
</ul>
<h4><a id="%E4%BD%BF%E7%94%A8delegate" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用delegate</h4>
<p>Session中的task共享一个公共delegate，用于处理各种事件。如果不需要通过delegate处理事件，可以在创建session时传入<code>nil</code>。<br />
<strong>注意</strong>，<code>NSURLSession</code>会强引用<code>delegate</code>属性直到app退出或显式使session失效。如果你没有使session失效，会造成app内存泄漏。</p>
<pre class="line-numbers"><code class="language-objc">@interface NSURLSession : NSObject

...

@property (nullable, readonly, retain) id &lt;NSURLSessionDelegate&gt; delegate;

... 

@end
</code></pre>
<h4><a id="%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>线程安全性</h4>
<p>URL Session API本身是完全<strong>线程安全</strong>的。您可以在任何线程上下文中自由创建session和task，并且当您的delegate方法调用completion handler时，工作将自动安排在正确的*委托队列(delegate queue)*中。</p>
<h3><a id="nsurlsessiontask" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NSURLSessionTask</h3>
<blockquote>
<p>在URL会话中执行的任务，如下载特定资源。</p>
</blockquote>
<p><code>NSURLSessionTask</code>类是session中task的基类，有三个子类可以使用：<code>NSURLSessionDataTask</code>、<code>NSURLSessionUploadTask</code>、<code>NSURLSessionDownloadTask</code>。</p>
<p><img src="https://objccn.io/images/issues/issue-5/NSURLSession.png" alt="" /></p>
<p>不同于直接使用 alloc-init 初始化方法，task 是由一个<code>NSURLSession</code>创建的。每个 task 的构造方法都有两个版本，一个带<code>completionHandler</code>，一个不带，例如下面<code>NSURLSessionDataTask</code>的构造方法。通过指定<code>completionHandler</code>这个 block 将创建一个隐式的 delegate，来替代该 task 原来的 delegate——session。对于需要override 原有 session task 的 delegate 的默认行为的情况，我们需要使用这种不带<code>completionHandler</code>的版本<sup class="footnote-ref"><a href="#fn-3" id="fnref-3_ref" data-footnote-ref>3</a></sup>。</p>
<pre class="line-numbers"><code class="language-objc">/* Creates a data task with the given request.  The request may have a body stream. */
- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request;

/*
 * data task convenience methods.  These methods create tasks that
 * bypass the normal delegate calls for response and data delivery,
 * and provide a simple cancelable asynchronous interface to receiving
 * data.  Errors will be returned in the NSURLErrorDomain, 
 * see &lt;Foundation/NSURLError.h&gt;.  The delegate, if any, will still be
 * called for authentication challenges.
 */
- (NSURLSessionDataTask *)dataTaskWithRequest:(NSURLRequest *)request 
                            completionHandler:(void (^)(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error))completionHandler;
</code></pre>
<p>所有的task都是可以取消，暂停或者恢复的。当一个 download task 取消时，可以通过选项来创建一个<em>恢复数据(resume data)</em>，然后可以传递给下一次新创建的 download task，以便继续之前的下载。</p>
<p><strong>注意</strong>，task的所有属性均支持KVO。</p>
<h3><a id="nsurlsessionconfiguration" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NSURLSessionConfiguration</h3>
<blockquote>
<p>用于定义URL会话的行为和策略的配置对象。</p>
</blockquote>
<p><code>NSURLSessionConfiguration</code> 对象用于对 <code>NSURLSession</code> 对象进行初始化。在初始化<code>NSURLSession</code>对象之前，必须正确配置<code>NSURLSessionConfiguration</code>对象，session 对象会 copy 一份配置数据，保存在自己的<code>configuration</code>属性中。一旦初始化完成，再次修改<code>NSURLSessionConfiguration</code>对象是不会影响到 session 对象的。</p>
<h4><a id="%E5%88%9B%E5%BB%BA" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建</h4>
<p><code>NSURLSessionConfiguration</code>类提供了三个方法创建配置对象：</p>
<ul>
<li><code>defaultSessionConfiguration</code>返回一个默认配置，具有相同的共享 <code>NSHTTPCookieStorage</code>，共享 <code>NSURLCache</code> 和共享 <code>NSURLCredentialStorage</code>。</li>
<li><code>ephemeralSessionConfiguration</code>返回一个临时配置，不会对cache，cookie或证书进行缓存。</li>
<li><code>+backgroundSessionConfigurationWithIdentifier:</code>返回一个后台配置，可用于创建后台session，可以子啊app未运行时在后台执行上传和下载。初始化时指定的标识符用于向任何可能在进程外恢复后台传输的*守护进程(daemon)*提供上下文。</li>
</ul>
<h4><a id="%E5%8F%AF%E9%85%8D%E7%BD%AE%E9%A1%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>可配置项</h4>
<p>参考苹果<a href="https://developer.apple.com/documentation/foundation/nsurlsessionconfiguration?language=objc">官方文档</a>。</p>
<h3><a id="%E5%A4%84%E7%90%86%E9%89%B4%E6%9D%83%E6%9F%A5%E8%AF%A2authentication-challenge" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>处理鉴权查询(Authentication Challenge)</h3>
<blockquote>
<p>当服务器要求对URL请求进行身份验证时，适当地做出响应。</p>
</blockquote>
<p>当客户端第一次发送请求的时候，服务器会返回一个包含公钥的受保护空间（也成为证书），当我们发送请求的时候，公钥会将请求加密再发送给服务器，服务器接到请求之后，用自带的私钥进行解密，如果正确再返回数据。这就是 HTTPS 的安全性所在<sup class="footnote-ref"><a href="#fn-4" id="fnref-4_ref" data-footnote-ref>4</a></sup>。</p>
<p><img src="https://upload-images.jianshu.io/upload_images/266345-9caefa5798c3660e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/554" alt="HTTPS请求" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;" /></p>
<p>在把请求发送给服务器的过程中，服务器可能会发出<em>鉴权查询(authentication challenge)</em>，这可以由共享的 cookie 或*机密存储(credential storage)*来自动响应，或者由被委托对象来响应。<br />
你需要根据收到的鉴权查询的性质，决定实现下面哪个代理方法：</p>
<ul>
<li>实现<code>NSURLSessionDelegate</code>协议的<code> URLSession:didReceiveChallenge:completionHandler:</code>方法，用来处理session范围的鉴权查询，这些查询可能来自*传输层安全协议(Transport Layer Security, TLS)*验证。成功处理这种查询将对 session 内的所有 task 有效。</li>
<li>实现<code>NSURLSessionTaskDelegate</code>协议的<code> URLSession:task:didReceiveChallenge:completionHandler</code>方法，用来处理特定 task 的鉴权查询，通常用于验证用户名/密码。Session 中的每个 task 都可以发起自己的鉴权查询。</li>
</ul>
<pre class="line-numbers"><code class="language-objc">/* If implemented, when a connection level authentication challenge
 * has occurred, this delegate will be given the opportunity to
 * provide authentication credentials to the underlying
 * connection. Some types of authentication will apply to more than
 * one request on a given connection to a server (SSL Server Trust
 * challenges).  If this delegate message is not implemented, the 
 * behavior will be to use the default handling, which may involve user
 * interaction. 
 */
- (void)URLSession:(NSURLSession *)session didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge
                                             completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler;
                                             
/* The task has received a request specific authentication challenge.
 * If this delegate is not implemented, the session specific authentication challenge
 * will *NOT* be called and the behavior will be the same as using the default handling
 * disposition. 
 */
- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task
                            didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge 
                              completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler;
</code></pre>
<p><strong>注意</strong>，从苹果的<a href="https://developer.apple.com/documentation/foundation/nsurlprotectionspace/nsurlprotectionspace_authentication_method_constants?language=objc">官方文档</a>可以获取所有鉴权查询的类型。</p>
<p>当 app 使用 https 协议发送请求时，<code>NSURLSessionDelegate</code>会收到<code>NSURLAuthenticationMethodServerTrust</code>类型的鉴权查询。不同于服务器要求验证你的app的身份，这个类型的鉴权查询提供了使你验证服务器证书的机会。大多数情况下，你应该让系统自动处理。除非你想要接受原本会被系统拒绝的服务器证书，或希望拒绝某个被系统接受的证书。<br />
下面的代码展示了如何访问服务器证书，以及如何验证证书并接受或拒绝它：</p>
<ul>
<li>如果证书有效，使用<code>serverTrust</code>创建一个<code>NSURLCredential</code>实例，然后调用<code>completionHandler()</code>，传入<code>NSURLSessionAuthChallengeUseCredential</code>和 credential 对象。这样系统将接受服务器证书。</li>
<li>如果证书无效，调用<code>completionHandler()</code>，传入<code>NSURLSessionAuthChallengeCancelAuthenticationChallenge</code>和<code>nil</code>。这样系统将拒绝服务器证书。</li>
</ul>
<pre class="line-numbers"><code class="language-objc">- (void)URLSession:(NSURLSession *)session task:(NSURLSessionTask *)task
                            didReceiveChallenge:(NSURLAuthenticationChallenge *)challenge 
                              completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler {

    NSURLSessionAuthChallengeDisposition disposition = NSURLSessionAuthChallengePerformDefaultHandling;
    NSURLCredential *credential = nil;
    
    if (![challenge.protectionSpace.authenticationMethod isEqualToString:NSURLAuthenticationMethodServerTrust]) {
        completionHandler(disposition, credential);
        return;
    }
    
    SecTrustRef trust = challenge.protectionSpace.serverTrust;
    SecTrustResultType checkResult;
    OSStatus trustEvalStatus = SecTrustEvaluate(trust, &amp;checkResult);
    if (trustEvalStatus == errSecSuccess 
        &amp;&amp; (checkResult == kSecTrustResultProceed 
            || checkResult == kSecTrustResultUnspecified)) {
            
        credential = [NSURLCredential credentialForTrust:trust];
        disposition = NSURLSessionAuthChallengeUseCredential;     
    }
    else {
        // Show a UI here warning the user the server credentials are invalid, and cancel the load.
        disposition = NSURLSessionAuthChallengeCancelAuthenticationChallenge;
    }
    
    completionHandler(disposition, credential);
}

</code></pre>
<p><strong>注意</strong>，参考苹果<a href="https://developer.apple.com/documentation/security/certificate_key_and_trust_services?language=objc">官方文档</a>，了解如何验证<code>SecTrustRef</code>实例或从中访问证书或实例的详细信息。</p>
<h2><a id="nsurlconnection-vs-nsurlsession" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>NSURLConnection vs. NSURLSession</h2>
<p><code>NSURLSession</code> 的 delegate 方法是 <code>NSURLConnection</code> 的演化的十年中对于 ad-hoc 模式的一个显著改善。您可以查看这个<a href="https://gist.github.com/floriankugler/6870499">映射表</a>来进行一个完整的概览。</p>
<h2><a id="ats" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ATS</h2>
<p>在 Apple 平台上，应用程序和应用程序扩展可以使用名为*App Transport Security(ATS)*的网络安全功能，默认情况下已启用。它通过确保您的应用程序的网络连接仅使用行业标准协议和没有已知缺陷的密码，从而提高了隐私和数据完整性。这有助于让用户相信您的应用程序不会意外地将传输的数据泄露给恶意方。</p>
<h3><a id="ats%E5%9F%BA%E6%9C%AC%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>ATS 基本配置</h3>
<p>通过在应用程序<code>Info.plist</code>文件中配置<code>NSAppTransportSecurity</code>键的方式自定义网络连接的安全性。<br />
默认情况下 ATS 在 iOS 9 和 macOS 10.11 及以后的系统上默认为开启状态。启用 ATS 后，所有的http请求必须使用HTTPS协议，尝试连接不安全的HTTP协议将会失败。ATS使用<em>Transport Layer Security(TLS)</em>，协议版本<code>1.2</code>。<br />
以下列表展示了<code>NSAppTransportSecurity</code>字典的整体结构，显示了所有可能的键，所有的键都是<em>可选(optional</em>)的<sup class="footnote-ref"><a href="#fn-6" id="fnref-6_ref" data-footnote-ref>5</a></sup>:</p>
<pre class="line-numbers"><code class="language-plain_text">NSAppTransportSecurity : Dictionary {
    NSAllowsArbitraryLoads : Boolean
    NSAllowsArbitraryLoadsForMedia : Boolean
    NSAllowsArbitraryLoadsInWebContent : Boolean
    NSAllowsLocalNetworking : Boolean
    NSExceptionDomains : Dictionary {
        &lt;domain-name-string&gt; : Dictionary {
            NSIncludesSubdomains : Boolean
            NSExceptionAllowsInsecureHTTPLoads : Boolean
            NSExceptionMinimumTLSVersion : String
            NSExceptionRequiresForwardSecrecy : Boolean   // Default value is YES
            NSRequiresCertificateTransparency : Boolean
        }
    }
}
</code></pre>
<h3><a id="%E8%87%AA%E5%AE%9A%E4%B9%89%E9%85%8D%E7%BD%AE" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>自定义配置</h3>
<p>有以下几种常见的自定义配置方式可供使用<sup class="footnote-ref"><a href="#fn-5" id="fnref-5_ref" data-footnote-ref>6</a></sup>：</p>
<h4><a id="%E5%85%A8%E9%83%A8%E5%90%AF%E7%94%A8ats" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>全部启用 ATS</h4>
<p>这是默认状态，直接使用 NSURLSession，NSURLConnection，CFURL 而不需要做任何配置。当然只能在 iOS 9 和 macOS 10.11 及以后的系统上有效。</p>
<h4><a id="%E5%85%A8%E9%83%A8%E5%90%AF%E7%94%A8ats%EF%BC%8C%E4%BD%86%E6%9C%89%E4%B8%80%E4%BA%9B%E4%BE%8B%E5%A4%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>全部启用 ATS，但有一些例外</h4>
<p>如果需要向不使用 ATS 的域发送请求，需要将这些域加入到<code>NSExceptionDomains</code>字典中。如果希望该域的所有子域全部禁用 ATS，需要设置<code>NSExceptionAllowsInsecureHTTPLoads</code>为<code>YES</code>，同时将<code>NSIncludesSubdomains</code>设置为<code>YES</code>。</p>
<p><img src="http://www.neglectedpotential.com/wp-content/uploads/ExampleB.png" alt="所有请求均启用 ATS，但有一些例外" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;" /></p>
<h4><a id="%E5%85%A8%E9%83%A8%E7%A6%81%E7%94%A8ats%EF%BC%8C%E4%BD%86%E6%9C%89%E4%B8%80%E4%BA%9B%E4%BE%8B%E5%A4%96" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>全部禁用 ATS，但有一些例外</h4>
<p>如果需要全部禁用 ATS，需要设置<code>NSAllowsArbitraryLoads</code>为<code>YES</code>，则所有的请求将不会使用 ATS。如果希望在一些例外的域使用 ATS，需要将这些域加入<code>NSExceptionDomains</code>字典。每个希望启用 ATS 的域都要在字典中将<code>NSExceptionAllowsInsecureHTTPLoads</code>设置为<code>NO</code>。</p>
<p><img src="http://www.neglectedpotential.com/wp-content/uploads/ExampleC.png" alt="全部禁用 ATS，但有一些例外" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;" /></p>
<h4><a id="%E9%99%8D%E7%BA%A7%E7%9A%84ats" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>降级的 ATS</h4>
<p>某些情况下你可能需要全部启用 ATS，但实际上并没有完全支持 ATS 的最佳实践。例如服务器支持 TLS1.2，但不支持<em>前向保密(forward secrecy)</em>。为了解决这个问题，可以使指定于支持 ATS，同时禁用前向保密，需要在<code>NSExceptionDomains</code>字典中加入该域，同时设置域的<code>NSExceptionRequiresForwardSecrecy</code>为<code>NO</code>。<br />
同样，如果需要支持前向保密，而TLS版本只有<code>1.1</code>，则需要设置<code>NSExceptionMinimumTLSVersion</code>为<code>TLSv1.1</code>。</p>
<p><img src="http://www.neglectedpotential.com/wp-content/uploads/ExampleD.png" alt="降级的 ATS" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;" /></p>
<h4><a id="%E5%85%A8%E9%83%A8%E7%A6%81%E7%94%A8ats" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>全部禁用 ATS</h4>
<p>如果需要全部禁用 ATS，只需将<code>NSAllowsArbitraryLoads</code>设置为<code>YES</code>。</p>
<p><img src="http://www.neglectedpotential.com/wp-content/uploads/ExampleE.png" alt="全部禁用 ATS" class="mw_img_center" style="display: block; clear:both; margin: 0 auto;" /></p>
<section class="footnotes" data-footnotes>
<ol>
<li id="fn-1">
<p><a href="https://developer.apple.com/documentation/foundation/url_loading_system?language=objc">URL Loading System</a> <a href="#fnref-1_ref" class="footnote-backref" data-footnote-backref aria-label="Back to content">&#8617;<a></p>
</li>
<li id="fn-2">
<p><a href="https://developer.apple.com/documentation/foundation/nsurlsession?language=objc">NSURLSession</a> <a href="#fnref-2_ref" class="footnote-backref" data-footnote-backref aria-label="Back to content">&#8617;<a></p>
</li>
<li id="fn-3">
<p><a href="https://objccn.io/issue-5-4/">从 NSURLConnection 到 NSURLSession</a> <a href="#fnref-3_ref" class="footnote-backref" data-footnote-backref aria-label="Back to content">&#8617;<a></p>
</li>
<li id="fn-4">
<p><a href="https://www.jianshu.com/p/4b5d2d47833d">iOS - HTTPS</a> <a href="#fnref-4_ref" class="footnote-backref" data-footnote-backref aria-label="Back to content">&#8617;<a></p>
</li>
<li id="fn-6">
<p><a href="https://developer.apple.com/library/archive/documentation/General/Reference/InfoPlistKeyReference/Articles/CocoaKeys.html#//apple_ref/doc/uid/TP40009251-SW33">NSAppTransportSecurity</a> <a href="#fnref-6_ref" class="footnote-backref" data-footnote-backref aria-label="Back to content">&#8617;<a></p>
</li>
<li id="fn-5">
<p><a href="http://www.neglectedpotential.com/2015/06/working-with-apples-application-transport-security/">WORKING WITH APPLE’S APP TRANSPORT SECURITY</a> <a href="#fnref-5_ref" class="footnote-backref" data-footnote-backref aria-label="Back to content">&#8617;<a></p>
</li>
</ol>
</section>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15365724007469.html">《iOS面试之道》读书笔记 - 远程通知服务器</a></h1>
			<p class="meta"><time datetime="2018-09-10T17:40:00+08:00" 
			pubdate data-updated="true">2018/09/10</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<blockquote>
<p>设置服务器以生成通知并将其推送到用户设备</p>
</blockquote>
<h2><a id="%E6%A6%82%E5%86%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>概况</h2>
<h3><a id="%E4%B8%BA%E9%80%9A%E7%9F%A5%E6%9E%84%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%9F%BA%E7%A1%80%E7%BB%93%E6%9E%84" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为通知构建自定义基础结构</h3>
<h3><a id="%E5%BB%BA%E7%AB%8B%E4%B8%8Eapn%E7%9A%84%E5%8F%AF%E4%BF%A1%E8%BF%9E%E6%8E%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>建立与APN的可信连接</h3>
<h3><a id="%E4%BA%86%E8%A7%A3apn%E6%8F%90%E4%BE%9B%E7%9A%84%E5%86%85%E5%AE%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>了解APN提供的内容</h3>
<h2><a id="%E7%94%9F%E6%88%90%E8%BF%9C%E7%A8%8B%E9%80%9A%E7%9F%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>生成远程通知</h2>
<h2><a id="%E5%90%91apns%E5%8F%91%E9%80%81%E9%80%9A%E7%9F%A5%E8%AF%B7%E6%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>向APNs发送通知请求</h2>
<h2><a id="%E6%97%A0%E5%A3%B0%E5%9C%B0%E6%8E%A8%E9%80%81app%E6%9B%B4%E6%96%B0" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>无声地推送app更新</h2>
<h2><a id="%E4%B8%8Eapns%E5%BB%BA%E7%AB%8B%E5%9F%BA%E4%BA%8E%E4%BB%A4%E7%89%8C%E7%9A%84%E8%BF%9E%E6%8E%A5-token-based-connection" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>与APNs建立基于令牌的连接(Token-Based Connection)</h2>
<h2><a id="%E4%B8%8Eapns%E5%BB%BA%E7%AB%8B%E5%9F%BA%E4%BA%8E%E8%AF%81%E4%B9%A6%E7%9A%84%E8%BF%9E%E6%8E%A5-certificate-based-connection" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>与APNs建立基于证书的连接(Certificate-Based Connection)</h2>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15365446737230.html">《iOS面试之道》读书笔记 - UserNotifications框架概况</a></h1>
			<p class="meta"><time datetime="2018-09-10T09:57:53+08:00" 
			pubdate data-updated="true">2018/09/10</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8%E6%9D%83%E9%99%90">请求使用权限</a>
<ul>
<li><a href="#%E5%9C%A8app%E5%90%AF%E5%8A%A8%E6%97%B6%E8%AF%B7%E6%B1%82%E6%8E%88%E6%9D%83">在app启动时请求授权</a></li>
<li><a href="#%E6%A0%B9%E6%8D%AE%E6%8E%88%E6%9D%83%E9%85%8D%E7%BD%AE%E6%94%AF%E6%8C%81%E7%9A%84%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B">根据授权配置支持的通知类型</a></li>
</ul>
</li>
<li><a href="#%E4%BB%8Eapp%E5%8F%91%E8%B5%B7%E6%9C%AC%E5%9C%B0%E9%80%9A%E7%9F%A5">从app发起本地通知</a>
<ul>
<li><a href="#%E5%88%9B%E5%BB%BA%E9%80%9A%E7%9F%A5%E7%9A%84%E5%86%85%E5%AE%B9notification-content">创建通知的内容(Notification Content)</a></li>
<li><a href="#%E6%8C%87%E5%AE%9A%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6notification-trigger">指定触发条件(Notification Trigger)</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E5%B9%B6%E6%B3%A8%E5%86%8C%E9%80%9A%E7%9F%A5%E8%AF%B7%E6%B1%82notification-request">创建并注册通知请求(Notification Request)</a></li>
<li><a href="#%E5%8F%96%E6%B6%88%E5%B7%B2%E8%A7%84%E5%88%92%E7%9A%84%E8%AF%B7%E6%B1%82">取消已规划的请求</a></li>
</ul>
</li>
<li><a href="#%E5%90%91apns%E6%B3%A8%E5%86%8C%E4%BD%A0%E7%9A%84app">向APNs注册你的app</a>
<ul>
<li><a href="#%E5%90%AF%E7%94%A8%E6%8E%A8%E5%8A%A8%E9%80%9A%E7%9F%A5%E5%8A%9F%E8%83%BD">启用推动通知功能</a></li>
<li><a href="#%E6%B3%A8%E5%86%8C%E4%BD%A0%E7%9A%84app%E5%B9%B6%E8%8E%B7%E5%8F%96%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%AE%BE%E5%A4%87%E4%BB%A4%E7%89%8C-device-token">注册你的app并获取应用程序的设备令牌(Device Token)</a></li>
<li><a href="#%E5%B0%86token%E8%BD%AC%E5%8F%91%E5%88%B0%E4%B8%9A%E5%8A%A1%E6%9C%8D%E5%8A%A1%E5%99%A8">将token转发到业务服务器</a></li>
</ul>
</li>
<li><a href="#%E5%A3%B0%E6%98%8E%E5%8F%AF%E6%93%8D%E4%BD%9C%E7%9A%84%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B">声明可操作的通知类型</a>
<ul>
<li><a href="#%E5%A3%B0%E6%98%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%93%8D%E4%BD%9Ccustom-action%E5%92%8C%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B-notification-type">声明自定义操作(Custom Action)和通知类型(Notification Type)</a></li>
<li><a href="#%E5%9C%A8%E6%9C%89%E6%95%88%E8%BD%BD%E8%8D%B7payload%E4%B8%AD%E5%8C%85%E5%90%AB%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%88%AB-notification-category">在有效载荷(Payload)中包含通知类别(Notification Category)</a></li>
<li><a href="#%E5%A4%84%E7%90%86%E9%80%89%E5%AE%9A%E7%9A%84%E6%93%8D%E4%BD%9C">处理选定的操作</a></li>
</ul>
</li>
<li><a href="#%E5%A4%84%E7%90%86%E9%80%9A%E7%9F%A5%E5%92%8C%E4%B8%8E%E9%80%9A%E7%9F%A5%E7%9B%B8%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C">处理通知和与通知相关的操作</a>
<ul>
<li><a href="#%E5%A4%84%E7%90%86app%E5%9C%A8%E5%89%8D%E5%8F%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%9A%E7%9F%A5">处理 app 在前台运行时的通知</a></li>
</ul>
</li>
<li><a href="#%E4%BF%AE%E6%94%B9%E9%80%9A%E7%9F%A5%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9">修改通知中的内容</a>
<ul>
<li><a href="#%E4%B8%BA%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%89%A9%E5%B1%95service-app-extension">为项目添加服务应用程序扩展(Service App Extension)</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%B1%95%E7%9A%84%E6%96%B9%E6%B3%95">实现扩展的方法</a></li>
<li><a href="#%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E9%80%9A%E7%9F%A5%E7%9A%84%E6%9C%89%E6%95%88%E8%B4%9F%E8%BD%BD">配置远程通知的有效负载</a></li>
</ul>
</li>
</ul>
</div>
<p>UserNotifications 框架可以用来从应用程序本地生成通知，也可以从你的服务器远程生成通知。对于<em>本地通知(local notifications)</em>，应用程序会创建通知内容，并指定触发通知传递的条件，如时间或位置。对于<em>远程通知(remote notifications)</em>（也称为推送通知），使用某个服务器生成通知，Apple推送通知服务（APN）处理将这些通知传递到用户的设备<sup class="footnote-ref"><a href="#fn-1" id="fnref-1_ref" data-footnote-ref>1</a></sup>。</p>
<h2><a id="%E8%AF%B7%E6%B1%82%E4%BD%BF%E7%94%A8%E6%9D%83%E9%99%90" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>请求使用权限</h2>
<blockquote>
<p>请用户允许显示警报(alerts)，播放声音或标记应用程序图标(badge)以响应通知。</p>
</blockquote>
<p>本地和远程通知通过alert，声音或badge引起用户的注意。当app未运行或处于后台时，仍然会发生这些互动。通知让用户知道app具有相关信息供他们查看。由于用户可能会认为基于通知​​的交互具有破坏性，因此必须显式地获得使用通知的权限<sup class="footnote-ref"><a href="#fn-2" id="fnref-2_ref" data-footnote-ref>2</a></sup>。</p>
<h3><a id="%E5%9C%A8app%E5%90%AF%E5%8A%A8%E6%97%B6%E8%AF%B7%E6%B1%82%E6%8E%88%E6%9D%83" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在app启动时请求授权</h3>
<p>在app启动时发起授权请求，在代码中获取<code>UNUserNotificationCenter</code>对象，并调用<code>requestAuthorizationWithOptions:completionHandler:</code>方法，指定app使用的所有交互类型。</p>
<pre class="line-numbers"><code class="language-objc">UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];
[center requestAuthorizationWithOptions:(UNAuthorizationOptionAlert | UNAuthorizationOptionBadge | UNAuthorizationOptionSound) 
                      completionHandler:^(BOOL granted, NSError * _Nullable error) {
                          // 基于用户的授权状态打开或关闭app的相关功能
                      }];

</code></pre>
<p>App首次发出此授权请求时，系统会提示用户授予或拒绝该请求并记录用户的响应。后续授权请求不会提示用户。</p>
<h3><a id="%E6%A0%B9%E6%8D%AE%E6%8E%88%E6%9D%83%E9%85%8D%E7%BD%AE%E6%94%AF%E6%8C%81%E7%9A%84%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>根据授权配置支持的通知类型</h3>
<p>在试图发起本地通知之前，请确保app已获得授权。即使最初获取了授权，用户也可以随时取消app的授权设置。用户也可以改变允许的交互类型，这可能回导致你改变通知的配置。</p>
<p>使用授权设置能够为用户提供更好的体验。即使你在<code>UNMutableNotificationContent</code>对象中指定了适当的信息，如果app没有获取相应的授权，系统也不会执行交互。调用<code>UNUserNotificationCenter</code>的<code>getNotificationSettingsWithCompletionHandler:</code>方法以获取当前的授权配置。</p>
<pre class="line-numbers"><code class="language-objc">UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];
[center getNotificationSettingsWithCompletionHandler:^(UNNotificationSettings * _Nonnull settings) {
    if (settings.authorizationStatus != UNAuthorizationStatusAuthorized) {
        return;
    }
    
    if (settings.alertSetting == UNNotificationSettingEnabled) {
        // 发送alert
        [self myScheduleAlertNotification];
    }
    else {
        // 发送声音和badge
        [self badgeAppAndPlaySound];
    }
}];
</code></pre>
<p>即使app未获取特定的授权，你也可能希望使用相关信息配置通知。如果<code>UNNotificationSettings</code>的<code>notificationCenterSetting</code>属性设置为<code>UNNotificationSettingEnabled</code>，则通知中心仍会显示包含alert的通知。同时当app处于前台时，通知也会传递到<code> userNotificationCenter:willPresentNotification:withCompletionHandler:</code>方法。</p>
<h2><a id="%E4%BB%8Eapp%E5%8F%91%E8%B5%B7%E6%9C%AC%E5%9C%B0%E9%80%9A%E7%9F%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>从app发起本地通知</h2>
<blockquote>
<p>当你想引起用户的注意时，请从app创建并安排通知。</p>
</blockquote>
<p>系统会根据你指定的时间或地点传递和处理通知。如果在app未运行或在后台运行通知时，系统会与用户进行交互。如果app位于前台，系统会将通知发送到app以进行处理<sup class="footnote-ref"><a href="#fn-3" id="fnref-3_ref" data-footnote-ref>3</a></sup>。</p>
<h3><a id="%E5%88%9B%E5%BB%BA%E9%80%9A%E7%9F%A5%E7%9A%84%E5%86%85%E5%AE%B9notification-content" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建通知的内容(Notification Content)</h3>
<p>使用<code>UNMutableNotificationContent</code>对象表示通知内容。</p>
<pre class="line-numbers"><code class="language-objc">UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init];
content.title = @&quot;Weekly Staff Meeting&quot;;
content.body = @&quot;Every Tuesday at 2pm&quot;;
</code></pre>
<h3><a id="%E6%8C%87%E5%AE%9A%E8%A7%A6%E5%8F%91%E6%9D%A1%E4%BB%B6notification-trigger" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>指定触发条件(Notification Trigger)</h3>
<p>为通知指定触发条件，使用<code>UNCalendarNotificationTrigger</code>，<code> UNTimeIntervalNotificationTrigger</code>或<code>UNLocationNotificationTrigger</code>对象。不同的 trigger 需要使用不同的参数，例如基于日历的 trigger 需要指定触发日期和时间。<br />
下面的代码展示了如何配置每周二下午2点发送的通知。<code>NSDateComponents</code>对象指定事件的触发时间。配置 trigger 的<code>repeats</code>属性会使系统在传递事件后重新规划该事件，从而实现周期性触发通知的效果。</p>
<pre class="line-numbers"><code class="language-objc">NSDateComponents *components = [[NSDateComponents alloc] init];
components.calendar = [NSCalendar currentCalendar];
components.weekday = 3;
components.hour = 14;

UNCalendarNotificationTrigger *trigger = [UNCalendarNotificationTrigger triggerWithDateMatchingComponents:components repeats:YES];
</code></pre>
<h3><a id="%E5%88%9B%E5%BB%BA%E5%B9%B6%E6%B3%A8%E5%86%8C%E9%80%9A%E7%9F%A5%E8%AF%B7%E6%B1%82notification-request" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>创建并注册通知请求(Notification Request)</h3>
<p>创建一个包含内容(content)和触发条件(trigger)的<code>UNNotificationRequest</code>对象，并调用<code>addNotificationRequest:withCompletionHandler:</code>方法使系统规划你的请求(request)。</p>
<pre class="line-numbers"><code class="language-objc">// Create the request
UNNotificationRequest *request = [UNNotificationRequest requestWithIdentifier:[NSUUID UUID] content:content trigger:trigger];

// Schedule the request with the system
UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];
[center addNotificationRequest:request withCompletionHandler:^(NSError * _Nullable error) {
    if (error) {
        // Handle any errors
    }
}];
</code></pre>
<h3><a id="%E5%8F%96%E6%B6%88%E5%B7%B2%E8%A7%84%E5%88%92%E7%9A%84%E8%AF%B7%E6%B1%82" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>取消已规划的请求</h3>
<p>一旦被规划，通知请求(Notification Request)将保持活动状态，直到满足其触发条件，或被显式地取消。一般来说，你可以在条件改变时取消通知，而不再需要通知用户。取消一个活动的通知请求，需要调用<code>UNUserNotificationCenter</code>的<code> removePendingNotificationRequestsWithIdentifiers:</code>或<code>removeAllPendingNotificationRequests</code>方法。</p>
<h2><a id="%E5%90%91apns%E6%B3%A8%E5%86%8C%E4%BD%A0%E7%9A%84app" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>向APNs注册你的app</h2>
<blockquote>
<p>与 APNs 通信并接收标识 app 的唯一设备令牌(unique device token)</p>
</blockquote>
<p>APNs 必须先知道用户设备的地址，然后才能向该设备发送通知。此地址采用设备令牌(device token)的形式，该设备令牌对于设备和应用程序都是唯一的。在启动时，app 与 APNs 通信并接收其t oken，然后将其转发到你的业务服务器。你的服务器包含该 token 及其发送的任何通知。</p>
<p><strong>注意</strong>，即使两个 app 都安装在同一设备上，一个 app 的 token 也无法用于其他 app。两个 app 都必须请求自己唯一的 token 并将其转发到业务服务器<sup class="footnote-ref"><a href="#fn-7" id="fnref-7_ref" data-footnote-ref>4</a></sup>。</p>
<h3><a id="%E5%90%AF%E7%94%A8%E6%8E%A8%E5%8A%A8%E9%80%9A%E7%9F%A5%E5%8A%9F%E8%83%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>启用推动通知功能</h3>
<p>要推送通知功能，app 必须具有合适的 entitlement。要将这些 entitlements 添加到 app，需要在Xcode项目中启用推送通知功能，如下图所示。在 iOS 中启用此选项会将 aps-environment 代码签名 entitlement 添加到 app 中。</p>
<p><img src="https://docs-assets.developer.apple.com/published/dd2f56dbe9/f3327ebb-70be-4a12-9a76-b1a8badc0cd0.png" alt="启用推送通知功能" /></p>
<p><strong>注意</strong>，在你的开发者帐户中，你还必须启用该项目的App ID推送通知服务。有关配置开发者帐户的详细信息，请转到<a href="https://developer.apple.com/account/#/overview/">开发者帐户</a>页面。</p>
<h3><a id="%E6%B3%A8%E5%86%8C%E4%BD%A0%E7%9A%84app%E5%B9%B6%E8%8E%B7%E5%8F%96%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E8%AE%BE%E5%A4%87%E4%BB%A4%E7%89%8C-device-token" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>注册你的app并获取应用程序的设备令牌(Device Token)</h3>
<p>使用 APNs 注册你的 app 并接收<em>全局唯一设备令牌(Globally Unique Device Token)</em>，该 token 是当前设备上你 app 的有效地址。业务服务器必须先具有此 token 才能向设备发送通知。<br />
每次使用苹果提供的API(Apple-provided APIs)启动 app 时，都需注册 app 并接收 token。注册过程在各个平台上类似：</p>
<ul>
<li>在iOS和tvOS中，调用<code>UIApplication</code>对象的<code>registerForRemoteNotifications</code>方法用来请求 token。注册成功后，你将在<code>application:didRegisterForRemoteNotificationsWithDeviceToken:</code>方法中收到 token。</li>
<li>在 macOS 中，调用<code>NSApplication</code>对象的<code>registerForRemoteNotificationTypes:</code>方法用来请求 token。注册成功后，你将在<code>application:didRegisterForRemoteNotificationsWithDeviceToken:</code>方法中收到 token。</li>
<li>在 watchOS 中，不需要显式地注册远程通知。用户的 iPhone 会在适当的时间自动将远程通知转发给watchOS应用程序。</li>
</ul>
<p>除了处理成功注册 APNs 之外，还要实现<code>application:didFailToRegisterForRemoteNotificationsWithError:</code>方法，处理失败的注册。如果用户的设备未连接到网络，APNs 服务器因任何原因无法访问，或者应用程序没有正确的代码签名权限，则注册可能会失败。发生故障时，设置一个标志并尝试稍后再次注册。</p>
<p>下面代码实现了远程通知和接收相应 token 所需的委托方法。<code>sendDeviceTokenToServer</code>方法是 app 用于将数据发送到其提供程序服务器的自定义方法。</p>
<pre class="line-numbers"><code class="language-objc">- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {
	// Override point for customization after application launch
	
	[[UIApplication sharedApplication] registerForRemoteNotifications];
	return YES;
}

- (void)application:(UIApplication *)application didRegisterForRemoteNotificationsWithDeviceToken:(NSData *)deviceToken {
	[self sendDeviceTokenToServer:deviceToken];
}

- (void)application:(UIApplication *)application didFailToRegisterForRemoteNotificationsWithError:(NSError *)error {
	// Try again later
}
</code></pre>
<p><strong>注意</strong>，切勿在本地存储中缓存 token。当用户从备份还原设备，用户在新设备上安装 app 以及用户重新安装操作系统时，APNs 会发出新 token。如果你要求系统每次都提供令牌，则可以保证获得最新的令牌。</p>
<h3><a id="%E5%B0%86token%E8%BD%AC%E5%8F%91%E5%88%B0%E4%B8%9A%E5%8A%A1%E6%9C%8D%E5%8A%A1%E5%99%A8" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>将token转发到业务服务器</h3>
<p>获取 token 后，打开从应用程序到提供商服务器的网络连接。安全地转发 token 以及识别服务器特定用户所需的任何其他信息。例如，可以包含用户的登录名或将其连接到业务服务的内容。加密任何通过网络发送的信息。<br />
在业务服务器上，将令牌存储在安全的位置，您可以在其中访问它们以发送通知。生成通知时，你的服务器必须能够向特定设备发送通知。因此，如果通知链接到用户的帐户，请使用用户的帐户信息存储设备令牌。由于用户可以拥有多个设备，因此需要处理多个设备令牌。</p>
<p>如需获取如何将 payload 和 token 发送到 APNs 的信息，参考<a href="https://developer.apple.com/documentation/usernotifications/setting_up_a_remote_notification_server/sending_notification_requests_to_apns?language=objc">向APNs发送通知请求</a>。</p>
<h2><a id="%E5%A3%B0%E6%98%8E%E5%8F%AF%E6%93%8D%E4%BD%9C%E7%9A%84%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>声明可操作的通知类型</h2>
<blockquote>
<p>区分通知并将操作按钮添加到通知界面</p>
</blockquote>
<p>*可操作的通知(Actionable notifications)*允许用户响应已发送的通知，而无需启动相应的app。其他通知在通知界面中显示信息，但用户唯一的操作方法是启动app。对于可操作的通知，除通知界面外，系统还显示一个或多个按钮。点击按钮会将所选操作发送到app，然后app在后台处理操作<sup class="footnote-ref"><a href="#fn-4" id="fnref-4_ref" data-footnote-ref>5</a></sup>。</p>
<h3><a id="%E5%A3%B0%E6%98%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%93%8D%E4%BD%9Ccustom-action%E5%92%8C%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%9E%8B-notification-type" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>声明自定义操作(Custom Action)和通知类型(Notification Type)</h3>
<p>必须在 app 启动时声明支持的所有<em>操作(action)</em>。你可以联合使用<em>类别</em>和<em>动作</em>对象来声明一个操作：使用<code>UNNotificationCategory</code>对象定义 app 支持的通知类型，使用<code>UNNotificationAction</code>对象定义要为每种类型显示的按钮。例如，一个会议邀请的通知可能包括接受或拒绝邀请的按钮。</p>
<p>每一个<code>UNNotificationCategory</code>对象都有一个唯一标识和用于处理该类型通知的选项。<code>identifier</code>属性中的字符串是类别对象中最重要的部分，生成通知时，必须在通知的*有效载荷(payload)*中包含相同的字符串。系统使用该字符串来定位相应的类别对象和任何操作。</p>
<p>要将操作与通知类别相关联，请为其分配一个或多个<code>UNNotificationAction</code>对象。每个操作对象都包含要显示给用户的本地化字符串以及表示你希望如何处理该操作的选项。例如，当您将操作标记为破坏性(destructive)时，系统会以不同的高亮形式显示该操作以指示其行为。</p>
<p>下面的代码展示了如何使用两个操作注册自定义类别。除标题和选项外，每个操作都有唯一的标识符。当用户选择操作时，系统会将该标识符传递给app。</p>
<pre class="line-numbers"><code class="language-objc">UNNotificationAction *acceptAction = [UNNotificationAction actionWithIdentifier:@&quot;ACCEPT_ACTION&quot; 
																		  title:@&quot;Accept&quot; 
																		options:UNNotificationActionOptionNone];
UNNotificationAction *declineAction = [UNNotificationAction actionWithIdentifier:@&quot;DECLINE_ACTION&quot; 
																		   title:@&quot;Decline&quot; 
																		 options:UNNotificationActionOptionNone];

// Define the notification type
UNNotificationCategory *meetingInviteCategory = [UNNotificationCategory categoryWithIdentifier:@&quot;MEETING_INVITATION&quot; 
																					   actions:@[acceptAction, declineAction] 
																			 intentIdentifiers:@[] 
																 hiddenPreviewsBodyPlaceholder:@&quot;&quot; 
																 					   options:UNNotificationCategoryOptionCustomDismissAction];

// Register the notification type
UNUserNotificationCenter *center = [UNUserNotificationCenter currentNotificationCenter];
[center setNotificationCategories:[NSSet setWithObject:meetingInviteCategory]];
</code></pre>
<p><strong>注意</strong>：所有操作(action)对象都必须具有唯一标识符。处理操作时，标识符是区分一个操作与另一个操作的唯一方法，即使这些操作属于不同的类别。</p>
<p>大多数操作只会让用户选择，但文本输入操作也允许用户键入基于自定义文本的<em>响应(response)</em>。然后，app可以将用户输入的响应合并到您对操作的处理中。例如，一个聊天app可以将键入的文本作为对传入消息的响应。要创建文本输入操作，需要创建<code>UNTextInputNotificationAction</code>对象而不是<code>UNNotificationAction</code>对象。当用户点击输入按钮时，系统显示可编辑的文本字段(test field)。当系统向app报告该操作时，系统会包含用户在响应中键入的文本。</p>
<h3><a id="%E5%9C%A8%E6%9C%89%E6%95%88%E8%BD%BD%E8%8D%B7payload%E4%B8%AD%E5%8C%85%E5%90%AB%E9%80%9A%E7%9F%A5%E7%B1%BB%E5%88%AB-notification-category" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>在有效载荷(Payload)中包含通知类别(Notification Category)</h3>
<p>系统仅显示那些payload包含有效类*别标识符字符串(Category Identifier)*的通知的操作。系统使用类别标识符来查找应用程序的已注册类别及其相关操作。然后，它使用该信息将操作按钮添加到通知界面。系统使用类别标识符来查找应用程序的已注册类别及其相关操作。然后，它使用该信息将操作按钮添加到通知界面。</p>
<p>下面的代码展示了如何创建一条会议邀请本地通知的内容(content)。要将类别分配给本地通知，需要将相应的字符串赋值给<code>UNMutableNotificationContent</code>对象的<code>categoryIdentifier</code>属性。除了基本信息之外，此代码还会将自定义数据添加到通知的<code>userInfo</code>字典中，稍后将使用该字典来处理该会议邀请。</p>
<pre class="line-numbers"><code class="language-objc">UNMutableNotificationContent *content = [[UNMutableNotificationContent alloc] init];
content.title = @&quot;Weekly Staff Meeting&quot;;
content.body = @&quot;Every Tuesday at 2pm&quot;;
content.userInfo = @{
	@&quot;MEETING_ID&quot;: meetingID,
	@&quot;USER_ID&quot;: userID
};
content.categoryIdentifier = @&quot;MEETING_INVITATION&quot;;
</code></pre>
<p>如果是在远程通知中添加类别标识符，需要将<code>category</code>字段添加到 JSON payload的<code>aps</code>字典中。</p>
<pre class="line-numbers"><code class="language-json">{
   &quot;aps&quot; : {
      &quot;category&quot; : &quot;MEETING_INVITATION&quot;
      &quot;alert&quot; : {
         &quot;title&quot; : &quot;Weekly Staff Meeting&quot;
         &quot;body&quot; : &quot;Every Tuesday at 2pm&quot;
      },
   },
   &quot;MEETING_ID&quot; : &quot;123456789&quot;,
   &quot;USER_ID&quot; : &quot;ABCD1234&quot;
}
</code></pre>
<h3><a id="%E5%A4%84%E7%90%86%E9%80%89%E5%AE%9A%E7%9A%84%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>处理选定的操作</h3>
<p>App必须处理它定义的所有操作。当用户选择一个操作时，系统会在后台启动 app 并通知共享的<code>UNUserNotificationCenter</code>对象实例，该对象会通知其<em>代理对象(delegate)</em>。使用代理对象的<code>userNotificationCenter:didReceiveNotificationResponse:withCompletionHandler:</code>方法来识别所选操作并提供适当的响应。</p>
<p>下面的代码实现了管理会议邀请的 app 的委托方法。该方法使用响应的<code>actionIdentifier</code>属性来确定是接受还是拒绝给定的邀请。它还依赖于通知有效载荷中的自定义数据来成功处理通知。完成处理操作后，应当始终调用<em>完成处理程序(completion handler)</em>。</p>
<pre class="line-numbers"><code class="language-objc">- (void)userNotificationCenter:(UNUserNotificationCenter *)center 
didReceiveNotificationResponse:(UNNotificationResponse *)response 
		 withCompletionHandler:(void(^)(void))completionHandler {

	// Get the meeting ID from the original notification
	NSDictionary *userInfo = response.notification.request.content.userInfo;
	NSString *meetingID = userInfo[@&quot;MEETING_ID&quot;];
	NSString *userID = userInfo[@&quot;USER_ID&quot;];

	// Perform the task associated with the action
	if ([response.actionIdentifier isEqualToString:@&quot;ACCEPT_ACTION&quot;]) {
		[sharedMeetingManager acceptMeeting:meetingID forUser:userID];
	}
	else if ([response.actionIdentifier isEqualToString:@&quot;DECLINE_ACTION&quot;]) {
		[sharedMeetingManager declineMeeting:meetingID forUser:userID];
	}
	else {
		// Handle other actions…
	}

	// Always call the completion handler when done
	completionHandler();
}
</code></pre>
<h2><a id="%E5%A4%84%E7%90%86%E9%80%9A%E7%9F%A5%E5%92%8C%E4%B8%8E%E9%80%9A%E7%9F%A5%E7%9B%B8%E5%85%B3%E7%9A%84%E6%93%8D%E4%BD%9C" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>处理通知和与通知相关的操作</h2>
<blockquote>
<p>响应用户与系统通知界面的交互，包括处理应用程序的自定义操作</p>
</blockquote>
<p>通知(Notifications)是将信息呈现在用户面前的一种主要方式，同时 app 本身也可以响应这些通知。例如 app 可以响应这些操作<sup class="footnote-ref"><a href="#fn-5" id="fnref-5_ref" data-footnote-ref>6</a></sup>：</p>
<ul>
<li>用户从通知界面中选择的操作</li>
<li>App 在前台运行时收到的通知</li>
<li>静默通知</li>
<li>与<a href="https://developer.apple.com/documentation/pushkit?language=objc">PushKit</a>相关的通知</li>
</ul>
<h3><a id="%E5%A4%84%E7%90%86app%E5%9C%A8%E5%89%8D%E5%8F%B0%E8%BF%90%E8%A1%8C%E6%97%B6%E7%9A%84%E9%80%9A%E7%9F%A5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>处理 app 在前台运行时的通知</h3>
<p>如果 app 在前台运行时收到通知，系统会将该通知直接发送到 app。收到通知后，可以使用通知的有效负载(Payload)执行任何操作。例如，你可以更新 app 的界面以反映通知中包含的新信息。然后，你可以禁止或修改任何已规划的 alert。<br />
当通知到达时，系统调用<code>UNUserNotificationCenter</code>的*委托对象(delegate)<em>的<code>userNotificationCenter:willPresentNotification:withCompletionHandler:</code>方法。使用该方法处理通知，并让系统知道你希望如何继续。<br />
下面的代码实现了该方法。当会议邀请到达时，app 会调用其自定义的<code>queueMeetingForDelivery</code>方法在 app 界面中显示新邀请。App 还要求系统通过将值<code>UNNotificationPresentationOptionSound</code>传递给</em>完成处理程(completion handler)*来播放通知的声音。对于其他通知类型，该方法使通知静音。</p>
<pre class="line-numbers"><code class="language-objc">- (void)userNotificationCenter:(UNUserNotificationCenter *)center 
	   willPresentNotification:(UNNotification *)notification 
	     withCompletionHandler:(void (^)(UNNotificationPresentationOptions options))completionHandler {
	
	if ([notification.request.content.categoryIdentifier isEqualToString:@&quot;MEETING_INVITATION&quot;]) {
		// Retrieve the meeting details
		NSString *meetingID = userInfo[@&quot;MEETING_ID&quot;];
		NSString *userID = userInfo[@&quot;USER_ID&quot;];

		// Add the meeting to the queue
		[sharedMeetingManager queueMeetingForDelivery:meetingID forUser:userID];

		// Play a sound to let the user know about the invitation
		completionHandler(UNNotificationPresentationOptionSound);
		return;
	}
	else {
		// Handle other notification types...
	}

	// Don't alert the user for other types
	completionHandler(UNNotificationPresentationOptionNone);
}
</code></pre>
<p>如果你使用 PushKit 注册了应用，则针对 PushKit 类型的通知始终会直接发送到您的应用，并且永远不会向用户显示。如果 app 位于前台或后台，系统会为 app 提供处理通知的时间。如果 app 未运行，系统会在后台启动 app，以便它可以处理通知。要发送 PushKit 通知，你的服务器必须将通知的主题设置为适当的目标，例如您的应用程序的复杂性。有关注册PushKit通知的更多信息，请参阅<a href="https://developer.apple.com/documentation/pushkit?language=objc">PushKit</a>。</p>
<h2><a id="%E4%BF%AE%E6%94%B9%E9%80%9A%E7%9F%A5%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>修改通知中的内容</h2>
<blockquote>
<p>在用户的iOS设备上显示之前修改远程通知的有效负载(Payload)</p>
</blockquote>
<p>如果需要，你可能要在用户的iOS设备上修改远程通知的内容：</p>
<ul>
<li>解密以加密格式发送的数据。</li>
<li>下载大小超过最大有效载荷大小的图像或其他媒体附件。</li>
<li>更新通知的内容，可能是通过合并用户设备的数据。</li>
</ul>
<p>修改远程通知需要通知<em>服务应用程序扩展(service app extension)</em>，您可以将其包含在iOS应用程序包(bundle)中。应用程序扩展在向用户显示之前会接收远程通知的内容，从而在用户收到alert之前更新通知的有效负载(Payload)。你可以控制扩展程序处理哪些通知。</p>
<p><strong>注意</strong>，通知服务应用程序扩展仅对配置为向用户显示alert的远程通知进行操作。如果您的应用程序禁用了alert，或者有效负载仅指定播放声音或图标的标记，则扩展程序不生效<sup class="footnote-ref"><a href="#fn-6" id="fnref-6_ref" data-footnote-ref>7</a></sup>。</p>
<h3><a id="%E4%B8%BA%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E6%89%A9%E5%B1%95service-app-extension" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>为项目添加服务应用程序扩展(Service App Extension)</h3>
<p>通知服务应用扩展程序在你的iOS应用中作为单独的捆绑包发布。要将此扩展程序添加到您的应用中：</p>
<ol>
<li>在Xcode中选择 File &gt; New &gt; Target。</li>
<li>从 iOS &gt; Application section 中选择 Notification Service Extension。</li>
<li>点击 Next。</li>
<li>指定应用扩展程序的名称和其他配置详细信息。</li>
<li>点击 Finish。</li>
</ol>
<h3><a id="%E5%AE%9E%E7%8E%B0%E6%89%A9%E5%B1%95%E7%9A%84%E6%96%B9%E6%B3%95" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>实现扩展的方法</h3>
<p>Xcode提供的通知服务扩展模板包含了一个可供修改的默认实现：</p>
<ul>
<li><code>didReceiveNotificationRequest:withContentHandler:</code>方法可以使用更新的内容创建<code>UNMutableNotificationContent</code>对象。</li>
<li>使用<code>serviceExtensionTimeWillExpire</code>方法终止仍在运行的任何有效载荷修改任务。</li>
</ul>
<p><code>didReceiveNotificationRequest:withContentHandler:</code>方法大概只有30秒的时间来修改有效负载并调用提供的<em>完成处理程序(completion handler)</em>。如果你的代码需要更长的时间，系统将调用<code>serviceExtensionTimeWillExpire</code>方法，此时你必须立即向系统返回任何内容。如果你无法从任一方法调用完成处理程序，系统将显示通知的原始内容。</p>
<p>下面的代码实现了<code>UNNotificationServiceExtension</code>对象，该对象解密使用远程通知传递的加密消息的内容。<code>didReceiveNotificationRequest:withContentHandler:</code>方法解密数据并在通知内容成功时返回修改后的内容。如果不成功，或者时间到期，则扩展程序返回指示数据仍处于加密状态的内容。</p>
<pre class="line-numbers"><code class="language-objc">// Storage for the completion handler and content
@interface NotificationService ()
@property (nonatomic, strong) void (^contentHandler)(UNNotificationContent *contentToDeliver);
@property (nonatomic, strong) UNMutableNotificationContent *bestAttemptContent;
@end

@implementation NotificationService
// Modify the payload contents
- (void)didReceiveNotificationRequest:(UNNotificationRequest *)request 
				   withContentHandler:(void (^)(UNNotificationContent * _Nonnull))contentHandler {
	self.contentHandler = contentHandler;
    self.bestAttemptContent = [request.content mutableCopy];

	// Try to decode the encrypted message data
	NSData *encryptedData = bestAttemptContent.userInfo[@&quot;ENCRYPTED_DATA&quot;] ?: [NSData data];
	NSString *decryptedMessage = [self decript:encryptedData];
	bestAttemptContent.body = decryptedMessage ?: @&quot;(Encrypted)&quot;;

	// Always call the completion handler when done
	contentHandler(bestAttemptContent)
}

// Return something before time expires
- (void)serviceExtensionTimeWillExpire {
	// Mark the message as still encrypted
	bestAttemptContent.subtitle = @&quot;(Encrypted)&quot;;
	bestAttemptContent.body = @&quot;&quot;;
	contentHandler(bestAttemptContent);
}
@end
</code></pre>
<h3><a id="%E9%85%8D%E7%BD%AE%E8%BF%9C%E7%A8%8B%E9%80%9A%E7%9F%A5%E7%9A%84%E6%9C%89%E6%95%88%E8%B4%9F%E8%BD%BD" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>配置远程通知的有效负载</h3>
<p>仅当远程通知的有效负载包含以下信息时，系统才会执行通知内容应用程序扩展：</p>
<ul>
<li>有效负载必须包含<code>mutable-content</code>值为<code>1</code>。</li>
<li>有效负载必须包含<code>alert</code>字典，包含<code>title</code>，<code>subtitle</code>或<code>body</code>。</li>
</ul>
<p>下面的JSON数据展示了包含加密数据的通知 payload。设置<code>mutable-content</code>值为<code>1</code>，以便用户的设备知道运行相应的服务应用程序扩展。</p>
<pre class="line-numbers"><code class="language-json">{
   &quot;aps&quot; : {
      &quot;category&quot; : &quot;SECRET&quot;,
      &quot;mutable-content&quot; : 1,
    &quot;alert&quot; : {
         &quot;title&quot; : &quot;Secret Message!&quot;,
         &quot;body&quot;  : &quot;(Encrypted)&quot;
     },
   },
   &quot;ENCRYPTED_DATA&quot; : &quot;Salted__·öîQÊ$UDì_¶Ù∞è	Ω^¬%gq∞NÿÒQùw&quot;
}
</code></pre>
<section class="footnotes" data-footnotes>
<ol>
<li id="fn-1">
<p><a href="https://developer.apple.com/documentation/usernotifications?language=objc#topics">UserNotifications</a> <a href="#fnref-1_ref" class="footnote-backref" data-footnote-backref aria-label="Back to content">&#8617;<a></p>
</li>
<li id="fn-2">
<p><a href="https://developer.apple.com/documentation/usernotifications/asking_permission_to_use_notifications?language=objc">Asking Permission to Use Notifications</a> <a href="#fnref-2_ref" class="footnote-backref" data-footnote-backref aria-label="Back to content">&#8617;<a></p>
</li>
<li id="fn-3">
<p><a href="https://developer.apple.com/documentation/usernotifications/scheduling_a_notification_locally_from_your_app?language=objc">Scheduling a Notification Locally from Your App</a> <a href="#fnref-3_ref" class="footnote-backref" data-footnote-backref aria-label="Back to content">&#8617;<a></p>
</li>
<li id="fn-7">
<p><a href="https://developer.apple.com/documentation/usernotifications/registering_your_app_with_apns?language=objc">Registering Your App with APNs</a> <a href="#fnref-7_ref" class="footnote-backref" data-footnote-backref aria-label="Back to content">&#8617;<a></p>
</li>
<li id="fn-4">
<p><a href="https://developer.apple.com/documentation/usernotifications/declaring_your_actionable_notification_types?language=objc">Declaring Your Actionable Notification Types</a> <a href="#fnref-4_ref" class="footnote-backref" data-footnote-backref aria-label="Back to content">&#8617;<a></p>
</li>
<li id="fn-5">
<p><a href="https://developer.apple.com/documentation/usernotifications/handling_notifications_and_notification_related_actions?language=objc">Handling Notifications and Notification-Related Actions</a> <a href="#fnref-5_ref" class="footnote-backref" data-footnote-backref aria-label="Back to content">&#8617;<a></p>
</li>
<li id="fn-6">
<p><a href="https://developer.apple.com/documentation/usernotifications/modifying_content_in_newly_delivered_notifications?language=objc">Modifying Content in Newly Delivered Notifications</a> <a href="#fnref-6_ref" class="footnote-backref" data-footnote-backref aria-label="Back to content">&#8617;<a></p>
</li>
</ol>
</section>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15362253776879.html">《iOS面试之道》读书笔记 - 并发编程</a></h1>
			<p class="meta"><time datetime="2018-09-06T17:16:17+08:00" 
			pubdate data-updated="true">2018/09/06</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#os-x%E5%92%8C-ios%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-api">OS X 和 iOS 中的并发编程API</a>
<ul>
<li><a href="#dispatch-queues">Dispatch Queues</a></li>
<li><a href="#dispatch-sources">Dispatch Sources</a></li>
<li><a href="#operation-queues">Operation Queues</a></li>
</ul>
</li>
<li><a href="#%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%9D%912">并发编程中的坑[^2]</a>
<ul>
<li><a href="#%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB">资源共享</a></li>
<li><a href="#%E4%BA%92%E6%96%A5%E9%94%81">互斥锁</a></li>
<li><a href="#%E6%AD%BB%E9%94%81">死锁</a></li>
<li><a href="#%E8%B5%84%E6%BA%90%E9%A5%A5%E9%A5%BF">资源饥饿</a></li>
<li><a href="#%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC">优先级反转</a></li>
</ul>
</li>
</ul>
</div>
<p>并发(Concurrency)的概念即在同一时间运行多个任务(Task)。过去，将并发引入应用程序需要创建一个或多个其他线程(Thread)。然而编写直接操作线程的代码极具挑战性，你必须手动使用系统底层API。鉴于应用程序的最佳线程数可以根据当前系统负载和底层硬件动态更改，实现正确的线程解决方案会变得非常困难。此外，通常与线程一起使用的同步机制增加了软件设计的复杂性和风险，而没有任何改进性能的保证。</p>
<h2><a id="os-x%E5%92%8C-ios%E4%B8%AD%E7%9A%84%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B-api" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>OS X 和 iOS 中的并发编程API</h2>
<p>与传统的基于线程的系统和应用程序相比，OS X 和 iOS 都提供了异步的并发任务执行方法。应用程序只需定义特定任务，然后让系统执行它们，而不是直接创建线程。通过让系统管理线程，应用程序获得了原始线程无法实现的可伸缩性级别。应用程序开发人员还可以获得更简单，高效的编程模型。<sup class="footnote-ref"><a href="#fn-1" id="fnref-1_ref" data-footnote-ref>1</a></sup></p>
<ul>
<li>
<p><code>Dispatch Queues</code>是一种基于C的用于执行自定义任务的机制。Dispatch Queues 串行或并行地执行任务，同时保证任务是先进先出的，换句话说，Dispatch Queues 中任务的<strong>执行</strong>完成顺序与任务的<strong>添加</strong>顺序是一致的。串行的 Dispatch Queue 同一时间只在一个线程上执行任务，需要等待上个任务完成，才能开始下个任务。并行的Dispatch Queue 同一时间执行多个任务，不需要等待上个任务完成。Dispatch Queues 有如下优势：</p>
<ul>
<li>提供简单易用的编程接口</li>
<li>提供自动和全方位的线程池管理</li>
<li>提供汇编级别的执行速度</li>
<li>更好的内存效率</li>
<li>加载时不会陷入内核</li>
<li>任务的异步调用不会导致死锁</li>
<li>竞争条件下合适的粒度</li>
<li>串行队列提供更加有效的同步机制</li>
</ul>
</li>
<li>
<p><code>Dispatch Sources</code>是一种基于C用于异步处理特定类型的系统事件的机制。调度源封装有关特定类型的系统事件的信息，并在发生该事件时将特定的块对象或函数提交给调度队列。你可以使用调度源来监视以下类型的系统事件：</p>
<ul>
<li>Timers</li>
<li>Signal handlers</li>
<li>描述符相关事件</li>
<li>进程相关事件</li>
<li>Mach端口事件</li>
<li>自定义的触发事件</li>
</ul>
</li>
<li>
<p><code>Operation Queues</code> Cocoa 中的 Operation Queue 与并发 Dispatch Queue 是等价的，由<code>NSOperationQueue</code>类实现。Dispatch Queue 始终以先进先出顺序执行任务，而Operation Queue 在确定任务的执行顺序时会考虑其他因素。其中主要因素是给定任务是否取决于其他任务的完成。你可以在定义任务时配置<a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html#//apple_ref/doc/uid/TP40008091-CH101-SW17">依赖关系</a>，用来实现复杂的任务执行顺序。</p>
</li>
</ul>
<h3><a id="dispatch-queues" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dispatch Queues</h3>
<h3><a id="dispatch-sources" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Dispatch Sources</h3>
<h3><a id="operation-queues" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Operation Queues</h3>
<h2><a id="%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E4%B8%AD%E7%9A%84%E5%9D%912" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>并发编程中的坑<sup class="footnote-ref"><a href="#fn-2" id="fnref-2_ref" data-footnote-ref>2</a></sup></h2>
<h3><a id="%E8%B5%84%E6%BA%90%E5%85%B1%E4%BA%AB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>资源共享</h3>
<h3><a id="%E4%BA%92%E6%96%A5%E9%94%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>互斥锁</h3>
<h3><a id="%E6%AD%BB%E9%94%81" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>死锁</h3>
<h3><a id="%E8%B5%84%E6%BA%90%E9%A5%A5%E9%A5%BF" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>资源饥饿</h3>
<h3><a id="%E4%BC%98%E5%85%88%E7%BA%A7%E5%8F%8D%E8%BD%AC" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>优先级反转</h3>
<section class="footnotes" data-footnotes>
<ol>
<li id="fn-1">
<p><a href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/Introduction/NaN">Concurrency Programming Guide - Concurrency and Application Design</a> <a href="#fnref-1_ref" class="footnote-backref" data-footnote-backref aria-label="Back to content">&#8617;<a></p>
</li>
<li id="fn-2">
<p><a href="https://www.objccn.io/issue-2-1/">并发编程：API 及挑战</a> <a href="#fnref-2_ref" class="footnote-backref" data-footnote-backref aria-label="Back to content">&#8617;<a></p>
</li>
</ol>
</section>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="15360488544502.html">《iOS面试之道》读书笔记 - atomic/nonatomic</a></h1>
			<p class="meta"><time datetime="2018-09-04T16:14:14+08:00" 
			pubdate data-updated="true">2018/09/04</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#%E4%BD%BF%E7%94%A8atomic%E4%BF%AE%E9%A5%B0%E7%9A%84-property%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%EF%BC%9F">使用 atomic 修饰的 property 是如何保证原子性的？</a></li>
<li><a href="#%E4%BD%BF%E7%94%A8atomic%E4%BF%AE%E9%A5%B0%E7%9A%84-property%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F">使用 atomic 修饰的 property 是线程安全的吗？</a></li>
<li><a href="#%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81property%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9F">如何保证 property 的线程安全性？</a></li>
</ul>
</div>
<p><code>atomic</code>和<code>nonatomic</code>用于在定义 property 时指明其原子性：</p>
<ul>
<li><code>atomic</code>表示是原子性的，调用该 property 的 getter 和 setter 会保证对象的完整性。多线程操作时，任何调用都可以得到一个完整的对象，因此速度较慢。</li>
<li><code>nonatomic</code>表示是<strong>非</strong>原子性的，调用该 property 的 getter 和 setter 不保证对象的完整性。多个线程对它进行访问，它可能会返回未初始化的对象，因此速度较快。</li>
</ul>
<p><strong>注意</strong>，以上讨论仅对编译器自动生成的 getter/setter 有效。如果你自己实现了 getter/setter，无论使用 atomic/nonatomic，property 的原子性都将取决于你自己的实现。</p>
<h2><a id="%E4%BD%BF%E7%94%A8atomic%E4%BF%AE%E9%A5%B0%E7%9A%84-property%E6%98%AF%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E5%8E%9F%E5%AD%90%E6%80%A7%E7%9A%84%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用 atomic 修饰的 property 是如何保证原子性的？</h2>
<p>对于任何没有手动实现的属性，编译器都会生成一个<code>objc_getProperty_non_gc</code>的函数作为 getter，同时生成一个<code>objc_setProperty_non_gc</code>的函数作为 setter。</p>
<p>从<code>objc_getProperty_non_gc</code>函数的源代码可以看到<sup class="footnote-ref"><a href="#fn-1" id="fnref-1_ref" data-footnote-ref>1</a></sup>：</p>
<pre class="line-numbers"><code class="language-c">// objc-accessors.mm

id objc_getProperty_non_gc(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic) {
    if (offset == 0) {
        return object_getClass(self);
    }

    // Retain release world
    id *slot = (id*) ((char*)self + offset);
    if (!atomic) return *slot;
        
    // Atomic retain release world
    spinlock_t&amp; slotlock = PropertyLocks[slot];
    slotlock.lock();
    id value = objc_retain(*slot);
    slotlock.unlock();
    
    // for performance, we (safely) issue the autorelease OUTSIDE of the spinlock.
    return objc_autoreleaseReturnValue(value);
}
</code></pre>
<p>而<code>objc_setProperty_non_gc</code>函数最终将调到<code>reallySetProperty</code>函数<sup class="footnote-ref"><a href="#fn-2" id="fnref-2_ref" data-footnote-ref>2</a></sup>：</p>
<pre class="line-numbers"><code class="language-c">// objc-accessors.mm

static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy)
{
    if (offset == 0) {
        object_setClass(self, newValue);
        return;
    }

    id oldValue;
    id *slot = (id*) ((char*)self + offset);

    if (copy) {
        newValue = [newValue copyWithZone:nil];
    } else if (mutableCopy) {
        newValue = [newValue mutableCopyWithZone:nil];
    } else {
        if (*slot == newValue) return;
        newValue = objc_retain(newValue);
    }

    if (!atomic) {
        oldValue = *slot;
        *slot = newValue;
    } else {
        spinlock_t&amp; slotlock = PropertyLocks[slot];
        slotlock.lock();
        oldValue = *slot;
        *slot = newValue;        
        slotlock.unlock();
    }

    objc_release(oldValue);
}
</code></pre>
<p>其中处理 atomic 的分支里，getter/setter 都使用了在<code>PropertyLocks</code>中的128个<a href="https://en.wikipedia.org/wiki/Spinlock">自旋锁(Spinlock)</a>中的1个来给操作上锁。这是一种务实和快速的方式，最糟糕的情况下，如果遇到了哈希碰撞，那么 setter 需要等待另一个和它无关的 setter 完成之后再进行工作<sup class="footnote-ref"><a href="#fn-3" id="fnref-3_ref" data-footnote-ref>3</a></sup>。</p>
<h2><a id="%E4%BD%BF%E7%94%A8atomic%E4%BF%AE%E9%A5%B0%E7%9A%84-property%E6%98%AF%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%9A%84%E5%90%97%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>使用 atomic 修饰的 property 是线程安全的吗？</h2>
<p>考虑对一个 nonatomic 的整形变量<code>integer</code>进行加1操作，可分为三个步骤：首先从内存中取出原始值，然后加1，最后将修改后的值写回内存。<br />
现在有<code>A</code>和<code>B</code>两个并发线程，分别对<code>integer</code>进行加1操作，那么问题来了：两个线程都从变量中取出了原始值，假设<code>17</code>，然后<code>A</code>将值加1，然后将结果<code>18</code>写回内存；同时<code>B</code>也将值加1后将结果<code>18</code>写回内存。此时<code>integer</code>被加1了两次，但最终值却是<code>18</code>。</p>
<p><img src="https://www.objccn.io/images/issues/issue-2/race-condition.png" alt="" /></p>
<p>这个问题称为<a href="https://www.objccn.io/issue-2-1/">竞态条件</a>，atomic 通过在读写时加入自旋锁，能保证对象的完整性，保护你免于在 setter 中遭遇到竞态条件的困扰。<br />
但这并<strong>不</strong>代表使用 atomic 就是线程安全的。考虑三个并发线程<code>A</code>，<code>B</code>和<code>C</code>，其中<code>A</code>和<code> B</code>对变量<code>integer</code>进行加1操作，<code>C</code>从变量<code>integer</code>中读取数据。因为三个线程是并发的，所以<code>C</code>读取数据的时机可能在其他两个写入数据的线程<code>A</code>、<code>B</code>之前，或在他们两个之间，也可能在他们两个之后，导致<code>C</code>读到的数据可能是<code>17</code>、<code>18</code>或<code>19</code>。</p>
<h2><a id="%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81property%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E6%80%A7%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>如何保证 property 的线程安全性？</h2>
<p>没有银弹，具体问题具体分析。<code>@synchronized</code>和<code>dispatch_queue</code>都是可选的解决方案，但也都各有利弊。这里就不展开说明了，那将又是一大块篇幅。</p>
<section class="footnotes" data-footnotes>
<ol>
<li id="fn-1">
<p><a href="https://github.com/opensource-apple/objc4/blob/master/runtime/objc-accessors.mm#L48">objc-accessors.mm - objc_getProperty_non_gc</a> <a href="#fnref-1_ref" class="footnote-backref" data-footnote-backref aria-label="Back to content">&#8617;<a></p>
</li>
<li id="fn-2">
<p><a href="https://github.com/opensource-apple/objc4/blob/master/runtime/objc-accessors.mm#L70">objc-accessors.mm - reallySetProperty</a> <a href="#fnref-2_ref" class="footnote-backref" data-footnote-backref aria-label="Back to content">&#8617;<a></p>
</li>
<li id="fn-3">
<p><a href="https://www.objccn.io/issue-2-4/">线程安全类的设计</a> <a href="#fnref-3_ref" class="footnote-backref" data-footnote-backref aria-label="Back to content">&#8617;<a></p>
</li>
</ol>
</section>


		</div>

		

	</article>
 
	<article>
		 <header>
		  	<h1 class="entry-title"><a href="ios-mian-shi-zhi-dao-du-shu-bi.html">《iOS面试之道》读书笔记 - NSRunLoop</a></h1>
			<p class="meta"><time datetime="2018-09-04T13:40:02+08:00" 
			pubdate data-updated="true">2018/09/04</time></p>
		 </header>
	  	<div class="entry-content">
		  	
		  	<div class="mweb_toc"><ul>
<li><a href="#run-loop%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">Run Loop 基本概念</a></li>
<li><a href="#run-loop%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB">Run Loop 与线程的关系</a></li>
<li><a href="#run-loop%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86">Run Loop 的组成部分</a></li>
<li><a href="#%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8run-loop%EF%BC%9F">何时使用 Run Loop？</a>
<ul>
<li><a href="#timer">Timer</a></li>
<li><a href="#performselector">performSelector:</a></li>
</ul>
</li>
</ul>
</div>
<h2><a id="run-loop%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Run Loop 基本概念</h2>
<p><code>Run Loop</code>就是一个在线程(thread)里不停执行的do-while循环。当线程接收到事件(event)时，Run Loop 内的事件处理会使用对应的句柄(handler)处理事件。<br />
Run Loop 接受的事件可分为两种不同的源(source)，<code>Input source</code>传递异步事件，通常是其他线程或应用发送过来的消息(message)。<code>Timer sources</code>传递同步事件，即发生于特定时间的或以一定时间间隔循环发送的事件。</p>
<p><img src="https://developer.apple.com/library/ios/documentation/Cocoa/Conceptual/Multithreading/Art/runloop.jpg" alt="" /></p>
<p>上图展示了 Run Loop 的工作原理：Run Loop 运行与线程之中，从<code>Input source</code>和<code>Timer sources</code>接受事件，然后调用相应的 handler 处理事件。iOS框架 Foundation 中定义了 Run Loop 的实现类<a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/Classes/NSRunLoop/Description.html#//apple_ref/occ/cl/NSRunLoop"><code>NSRunLoop</code></a>。</p>
<h2><a id="run-loop%E4%B8%8E%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%85%B3%E7%B3%BB" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Run Loop 与线程的关系</h2>
<p>Run Loop 与线程是一一对应的关系。每一个线程都有且仅有一个 Run Loop 与其对应，没有线程，就没有 Run Loop。在iOS应用中，主线程的 Run Loop 是默认启动的，而其他线程的 Run Loop 默认是不启动的。苹果为我们提供了两种获取 Run Loop 对象的方式：</p>
<ul>
<li>使用<code>[NSRunLoop currentRunLoop]</code>获取<code>NSRunLoop</code>对象</li>
<li>使用<a href="https://developer.apple.com/documentation/corefoundation/1542428-cfrunloopgetcurrent"><code>CFRunLoopGetCurrent</code></a>函数获取<a href="https://developer.apple.com/documentation/corefoundation/cfrunloopref?language=objc"><code>CFRunLoopRef</code></a></li>
</ul>
<p>获取的 Run Loop 对象的线程安全性取决于你所使用的API。Core Foundation 中的函数通常是线程安全的，可以从任何线程调用。但是，如果你正在执行修改 Run Loop 配置的操作，那么最佳实践是尽可能在 Run Loop 所在的线程进行这些操作。<br />
<code>NSRunLoop</code>类不具有线程安装性。如果你使用<code>NSRunLoop</code>类来修改 Run Loop，则应仅从持有该 Run Loop 的线程内执行操作。</p>
<h2><a id="run-loop%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Run Loop 的组成部分</h2>
<p>一个 Run Loop 包含多个 Mode，每个 Mode 包含多个 Sources、Objservers 和 Timers。每次调用 Run Loop 时，需要指定一种 Mode，此时 Run Loop 只能处理该 Mode 包含的Sources、Objservers 和 Timers<sup class="footnote-ref"><a href="#fn-2" id="fnref-2_ref" data-footnote-ref>1</a></sup>。</p>
<p><img src="https://blog.ibireme.com/wp-content/uploads/2015/05/RunLoop_0.png" alt="" /></p>
<p>苹果<a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW12">官方文档</a>中提到的 Mode 类型有五种：</p>
<ul>
<li><a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/TypesAndConstants/FoundationTypesConstants/Description.html#//apple_ref/c/data/NSDefaultRunLoopMode"><code>NSDefaultRunLoopMode</code></a></li>
<li><a href="https://developer.apple.com/library/archive/documentation/LegacyTechnologies/WebObjects/WebObjects_3.5/Reference/Frameworks/ObjC/Foundation/TypesAndConstants/FoundationTypesConstants/Description.html#//apple_ref/c/data/NSConnectionReplyMode"><code>NSConnectionReplyMode</code></a></li>
<li><a href="https://developer.apple.com/documentation/appkit/nsmodalpanelrunloopmode"><code>NSModalPanelRunLoopMode</code></a></li>
<li><a href="https://developer.apple.com/documentation/appkit/nseventtrackingrunloopmode"><code>NSEventTrackingRunLoopMode</code></a></li>
<li><a href="https://developer.apple.com/documentation/foundation/runloop/mode/1408609-common"><code>NSRunLoopCommonModes</code></a></li>
</ul>
<p>iOS中可供调用的只有<code>NSDefaultRunLoopMode</code>和<code>NSRunLoopCommonModes</code>两个，其中<code>NSRunLoopCommonModes</code>是一个集合，其中默认包括<code>NSDefaultRunLoopMode</code>和<code>NSEventTrackingRunLoopMode</code>。</p>
<h2><a id="%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8run-loop%EF%BC%9F" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>何时使用 Run Loop？</h2>
<p>苹果官方文档<sup class="footnote-ref"><a href="#fn-1" id="fnref-1_ref" data-footnote-ref>2</a></sup>指出，需要显式运行 Run Loop 的唯一时机是为应用程序创建辅助线程(secondary thread)时。例如，如果你需要执行以下任何操作，则需要启动 Run Loop：</p>
<ul>
<li>使用端口(mach port)或自定义输入源(custom input source)与其他线程通信。</li>
<li>在线程中使用计时器(timers)。</li>
<li>使用任何<code>performSelector</code>方法。</li>
<li>保持线程以执行周期任务。</li>
</ul>
<h3><a id="timer" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>Timer</h3>
<p>计时器源(timer source)在将来的预设时间将事件同步传递给线程。苹果为我们提供了两种计时器的实现，<a href="https://developer.apple.com/documentation/foundation/nstimer"><code>NSTimer</code></a>和<a href="https://developer.apple.com/documentation/corefoundation/cfrunlooptimer"><code>CFRunLoopTimerRef</code></a>。<br />
RunLoop为了节省资源，并不会在非常准确的时间点回调这个Timer。Timer 有个属性叫做 Tolerance (宽容度)，标示了当时间点到后，容许有多少最大误差。如果某个时间点被错过了，例如执行了一个很长的任务，则那个时间点的回调也会跳过去，不会延后执行。就比如等公交，如果 10:10 时我忙着玩手机错过了那个点的公交，那我只能等 10:20 这一趟了。^1</p>
<h3><a id="performselector" class="anchor" aria-hidden="true"><span class="octicon octicon-link"></span></a>performSelector:</h3>
<p>当调用<code>NSObject</code>的<code>performSelecter:afterDelay:</code>后，实际上其内部会创建一个 Timer 并添加到当前线程的 RunLoop 中。所以如果当前线程没有 RunLoop，则这个方法会失效。当调用<code>performSelector:onThread:</code>时，实际上其会创建一个 Timer 加到对应的线程去，同样的，如果对应线程没有 Run Loop 该方法也会失效。^1</p>
<section class="footnotes" data-footnotes>
<ol>
<li id="fn-2">
<p><a href="https://blog.ibireme.com/2015/05/18/runloop/">深入理解RunLoop</a> <a href="#fnref-2_ref" class="footnote-backref" data-footnote-backref aria-label="Back to content">&#8617;<a></p>
</li>
<li id="fn-1">
<p><a href="https://developer.apple.com/library/archive/documentation/Cocoa/Conceptual/Multithreading/RunLoopManagement/RunLoopManagement.html#//apple_ref/doc/uid/10000057i-CH16-SW12">Threading Programming Guide - Run Loops</a> <a href="#fnref-1_ref" class="footnote-backref" data-footnote-backref aria-label="Back to content">&#8617;<a></p>
</li>
</ol>
</section>


		</div>

		

	</article>
  
	<div class="pagination">
	
<a href="archives.html">Blog Archives</a>
	 
	    
	</div>
</div>
 <aside class="sidebar"> 

	<section>
	  <h1>Categories</h1>
	  <ul id="recent_posts">
	  
	      <li class="post">
	        <a href="%E3%80%8AiOS%E9%9D%A2%E8%AF%95%E4%B9%8B%E9%81%93%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0.html"><strong>《iOS面试之道》读书笔记&nbsp;(6)</strong></a>
	        
	        
	        
	      </li>
	   
	  </ul>
	</section>
	<section>
	  <h1>Recent Posts</h1>
	  <ul id="recent_posts">
	  
	      
		      <li class="post">
		        <a href="16566860725573.html">使用 framework 转换 XCFramework</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="16558196375003.html">记一次私有 pod 发布报错</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="wan-zhuan-cocoapods-xu-yao-le.html">玩转 CocoaPods 需要了解的 Ruby 基础知识</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="16553980014674.html">使用 LLDB Python API 自动存储后台请求数据用于单元测试</a>
		      </li>
	     
	  
	      
		      <li class="post">
		        <a href="15372506301626.html">JavaScript for Automation(JXA) 入门</a>
		      </li>
	     
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	  
	      
	   
	  </ul>
	</section>
	
</aside> </div></div>
  <footer role="contentinfo"><p>
  Copyright &copy; 2014 -  -
  <span class="credit">Powered by <a target="_blank" href="http://www.mweb.im">MWeb</a> &nbsp;&nbsp; Theme by <a href="http://octopress.org">Octopress</a></span>
</p>

</footer>



  














<style type="text/css">
  
/* PrismJS 1.14.0
https://prismjs.com/download.html#themes=prism-solarizedlight&languages=markup+css+clike+javascript */
/*
 Solarized Color Schemes originally by Ethan Schoonover
 http://ethanschoonover.com/solarized

 Ported for PrismJS by Hector Matos
 Website: https://krakendev.io
 Twitter Handle: https://twitter.com/allonsykraken)
*/

/*
SOLARIZED HEX
--------- -------
base03    #002b36
base02    #073642
base01    #586e75
base00    #657b83
base0     #839496
base1     #93a1a1
base2     #eee8d5
base3     #fdf6e3
yellow    #b58900
orange    #cb4b16
red       #dc322f
magenta   #d33682
violet    #6c71c4
blue      #268bd2
cyan      #2aa198
green     #859900
*/

code[class*="language-"],
pre[class*="language-"] {
  color: #657b83; /* base00 */
  font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace;
  text-align: left;
  white-space: pre;
  word-spacing: normal;
  word-break: normal;
  word-wrap: normal;

  line-height: 1.5;

  -moz-tab-size: 4;
  -o-tab-size: 4;
  tab-size: 4;

  -webkit-hyphens: none;
  -moz-hyphens: none;
  -ms-hyphens: none;
  hyphens: none;
}

pre[class*="language-"]::-moz-selection, pre[class*="language-"] ::-moz-selection,
code[class*="language-"]::-moz-selection, code[class*="language-"] ::-moz-selection {
  background: #073642; /* base02 */
}

pre[class*="language-"]::selection, pre[class*="language-"] ::selection,
code[class*="language-"]::selection, code[class*="language-"] ::selection {
  background: #073642; /* base02 */
}

/* Code blocks */
pre[class*="language-"] {
  padding: 1em;
  margin: .5em 0;
  overflow: auto;
  border-radius: 0.3em;
}

:not(pre) > code[class*="language-"],
pre[class*="language-"] {
  background-color: #fdf6e3; /* base3 */
}

/* Inline code */
:not(pre) > code[class*="language-"] {
  padding: .1em;
  border-radius: .3em;
}

.token.comment,
.token.prolog,
.token.doctype,
.token.cdata {
  color: #93a1a1; /* base1 */
}

.token.punctuation {
  color: #586e75; /* base01 */
}

.namespace {
  opacity: .7;
}

.token.property,
.token.tag,
.token.boolean,
.token.number,
.token.constant,
.token.symbol,
.token.deleted {
  color: #268bd2; /* blue */
}

.token.selector,
.token.attr-name,
.token.string,
.token.char,
.token.builtin,
.token.url,
.token.inserted {
  color: #2aa198; /* cyan */
}

.token.entity {
  color: #657b83; /* base00 */
  background: #eee8d5; /* base2 */
}

.token.atrule,
.token.attr-value,
.token.keyword {
  color: #859900; /* green */
}

.token.function,
.token.class-name {
  color: #b58900; /* yellow */
}

.token.regex,
.token.important,
.token.variable {
  color: #cb4b16; /* orange */
}

.token.important,
.token.bold {
  font-weight: bold;
}
.token.italic {
  font-style: italic;
}

.token.entity {
  cursor: help;
}


pre[class*="language-"].line-numbers {
    position: relative;
    padding-left: 3.8em;
    counter-reset: linenumber;
}

pre[class*="language-"].line-numbers > code {
    position: relative;
    white-space: inherit;
}

.line-numbers .line-numbers-rows {
    position: absolute;
    pointer-events: none;
    top: 0;
    font-size: 100%;
    left: -3.8em;
    width: 3em; /* works for line-numbers below 1000 lines */
    letter-spacing: -1px;
    border-right: 1px solid #999;

    -webkit-user-select: none;
    -moz-user-select: none;
    -ms-user-select: none;
    user-select: none;

}

    .line-numbers-rows > span {
        pointer-events: none;
        display: block;
        counter-increment: linenumber;
    }

        .line-numbers-rows > span:before {
            content: counter(linenumber);
            color: #999;
            display: block;
            padding-right: 0.8em;
            text-align: right;
        }

</style>
  
    


</body>
</html>